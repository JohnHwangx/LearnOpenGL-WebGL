/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var MyLibrary;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/1.getting_started/1.hello_triangle.ts":
/*!***************************************************!*\
  !*** ./src/1.getting_started/1.hello_triangle.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n\r\nconst vertexShaderSource = `#version 300 es\r\n\r\nin vec4 a_position;\r\nvoid main(){\r\n    gl_Position = a_position;\r\n}`;\r\nconst fragmentShaderSource = `#version 300 es\r\n\r\nprecision highp float;\r\nout vec4 outColor;\r\n\r\nvoid main(){\r\n    outColor = vec4(1, 0.5, 0.2, 1);\r\n}`;\r\nfunction createShader(gl, type, source) {\r\n    let shader = gl.createShader(type);\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n    let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    if (success) {\r\n        return shader;\r\n    }\r\n    console.log(gl.getShaderInfoLog(shader));\r\n    gl.deleteShader(shader);\r\n    return undefined;\r\n}\r\nfunction createProgram(gl, vertexShader, fragmentShader) {\r\n    let program = gl.createProgram();\r\n    gl.attachShader(program, vertexShader);\r\n    gl.attachShader(program, fragmentShader);\r\n    gl.linkProgram(program);\r\n    let success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n    if (success) {\r\n        return program;\r\n    }\r\n    console.log(gl.getProgramInfoLog(program));\r\n    gl.deleteProgram(program);\r\n    return undefined;\r\n}\r\nfunction main() {\r\n    let canvas = document.querySelector('#c');\r\n    let gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\r\n    let fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\r\n    let program = createProgram(gl, vertexShader, fragmentShader);\r\n    const vertices = [\r\n        -0.5, -0.5, 0.0,\r\n        0.5, -0.5, 0.0,\r\n        0.0, 0.5, 0.0 // top  \r\n    ];\r\n    let positionAttributeLocation = gl.getAttribLocation(program, 'a_position');\r\n    let vao = gl.createVertexArray();\r\n    gl.bindVertexArray(vao);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 3 * 4, 0);\r\n    gl.enableVertexAttribArray(positionAttributeLocation);\r\n    _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(gl.canvas);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    gl.clearColor(0.2, 0.3, 0.3, 1);\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n    gl.useProgram(program);\r\n    gl.bindVertexArray(vao);\r\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/1.getting_started/1.hello_triangle.ts?");

/***/ }),

/***/ "./src/1.getting_started/2.hello_triangle_indexed.ts":
/*!***********************************************************!*\
  !*** ./src/1.getting_started/2.hello_triangle_indexed.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n\r\nconst vertexShaderSource = `#version 300 es\r\n\r\nin vec4 a_position;\r\nvoid main(){\r\n    gl_Position = a_position;\r\n}`;\r\nconst fragmentShaderSource = `#version 300 es\r\n\r\nprecision highp float;\r\nout vec4 outColor;\r\n\r\nvoid main(){\r\n    outColor = vec4(1, 0.5, 0.2, 1);\r\n}`;\r\nfunction createShader(gl, type, source) {\r\n    let shader = gl.createShader(type);\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n    let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    if (success) {\r\n        return shader;\r\n    }\r\n    console.log(gl.getShaderInfoLog(shader));\r\n    gl.deleteShader(shader);\r\n    return undefined;\r\n}\r\nfunction createProgram(gl, vertexShader, fragmentShader) {\r\n    let program = gl.createProgram();\r\n    gl.attachShader(program, vertexShader);\r\n    gl.attachShader(program, fragmentShader);\r\n    gl.linkProgram(program);\r\n    let success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n    if (success) {\r\n        return program;\r\n    }\r\n    console.log(gl.getProgramInfoLog(program));\r\n    gl.deleteProgram(program);\r\n    return undefined;\r\n}\r\nfunction main() {\r\n    let canvas = document.querySelector('#c');\r\n    let gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\r\n    let fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\r\n    let program = createProgram(gl, vertexShader, fragmentShader);\r\n    const vertices = [\r\n        0.5, 0.5, 0.0,\r\n        0.5, -0.5, 0.0,\r\n        -0.5, -0.5, 0.0,\r\n        -0.5, 0.5, 0.0 // top left \r\n    ];\r\n    const indices = [\r\n        0, 1, 3,\r\n        1, 2, 3 // second Triangle\r\n    ];\r\n    let positionAttributeLocation = gl.getAttribLocation(program, 'a_position');\r\n    let vao = gl.createVertexArray();\r\n    gl.bindVertexArray(vao);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    let ebo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 3 * 4, 0);\r\n    gl.enableVertexAttribArray(positionAttributeLocation);\r\n    _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(gl.canvas);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    gl.clearColor(0.2, 0.3, 0.3, 1);\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n    gl.useProgram(program);\r\n    gl.bindVertexArray(vao);\r\n    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/1.getting_started/2.hello_triangle_indexed.ts?");

/***/ }),

/***/ "./src/1.getting_started/5.textures.ts":
/*!*********************************************!*\
  !*** ./src/1.getting_started/5.textures.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n\r\nconst vertexShaderSource = `#version 300 es\r\nin vec3 aPos;\r\nin vec3 aColor;\r\nin vec2 aTexCoord;\r\n\r\nout vec3 ourColor;\r\nout vec2 TexCoord;\r\n\r\nvoid main(){\r\n    gl_Position = vec4(aPos, 1.0);\r\n    ourColor = aColor;\r\n    TexCoord = vec2(aTexCoord.x, aTexCoord.y);\r\n}`;\r\nconst fragmentShaderSource = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nin vec3 ourColor;\r\nin vec2 TexCoord;\r\n\r\nuniform sampler2D texture1;\r\nvoid main(){\r\n    FragColor = texture(texture1, TexCoord) * vec4(ourColor, 1.0);;\r\n}`;\r\nfunction main() {\r\n    const canvas = document.querySelector('#c');\r\n    const gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let program = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createProgramFromStrings(gl, [vertexShaderSource, fragmentShaderSource]);\r\n    let positionAttibLocation = gl.getAttribLocation(program, 'aPos');\r\n    let colorAttribLocation = gl.getAttribLocation(program, 'aColor');\r\n    let texCoordAttibLocation = gl.getAttribLocation(program, 'aTexCoord');\r\n    const vertices = [\r\n        // positions          // colors           // texture coords\r\n        0.5, 0.5, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,\r\n        0.5, -0.5, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,\r\n        -0.5, -0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,\r\n        -0.5, 0.5, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0 // top left \r\n    ];\r\n    const indices = [\r\n        0, 1, 3,\r\n        1, 2, 3 // second triangle\r\n    ];\r\n    let vao = gl.createVertexArray();\r\n    gl.bindVertexArray(vao);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    let ebo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(positionAttibLocation, 3, gl.FLOAT, false, 8 * 4, 0);\r\n    gl.enableVertexAttribArray(positionAttibLocation);\r\n    gl.vertexAttribPointer(colorAttribLocation, 3, gl.FLOAT, false, 8 * 4, 3 * 4);\r\n    gl.enableVertexAttribArray(colorAttribLocation);\r\n    gl.vertexAttribPointer(texCoordAttibLocation, 2, gl.FLOAT, false, 8 * 4, 6 * 4);\r\n    gl.enableVertexAttribArray(texCoordAttibLocation);\r\n    let texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n    let image = new Image();\r\n    image.src = './resources/images/container.jpg';\r\n    image.addEventListener('load', () => {\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n        gl.generateMipmap(gl.TEXTURE_2D);\r\n        _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(gl.canvas);\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n        let textureUniformLocation = gl.getUniformLocation(program, 'texture1');\r\n        gl.clearColor(0.2, 0.3, 0.3, 1);\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n        gl.useProgram(program);\r\n        gl.bindVertexArray(vao);\r\n        gl.uniform1i(textureUniformLocation, 0);\r\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/1.getting_started/5.textures.ts?");

/***/ }),

/***/ "./src/1.getting_started/6.textures_combine.ts":
/*!*****************************************************!*\
  !*** ./src/1.getting_started/6.textures_combine.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n\r\nconst vertexShaderSource = `#version 300 es\r\nin vec3 aPos;\r\nin vec3 aColor;\r\nin vec2 aTexCoord;\r\n\r\nout vec3 ourColor;\r\nout vec2 TexCoord;\r\n\r\nvoid main(){\r\n    gl_Position = vec4(aPos, 1.0);\r\n    ourColor = aColor;\r\n    TexCoord = vec2(aTexCoord.x, aTexCoord.y);\r\n}`;\r\nconst fragmentShaderSource = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nin vec3 ourColor;\r\nin vec2 TexCoord;\r\n\r\nuniform sampler2D texture1;\r\nuniform sampler2D texture2;\r\nvoid main(){\r\n    FragColor = mix(texture(texture1,TexCoord),texture(texture2, TexCoord), 0.2);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.querySelector('#c');\r\n    const gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let program = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createProgramFromStrings(gl, [vertexShaderSource, fragmentShaderSource]);\r\n    let positionAttibLocation = gl.getAttribLocation(program, 'aPos');\r\n    let colorAttribLocation = gl.getAttribLocation(program, 'aColor');\r\n    let texCoordAttibLocation = gl.getAttribLocation(program, 'aTexCoord');\r\n    const vertices = [\r\n        // positions          // colors           // texture coords\r\n        0.5, 0.5, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,\r\n        0.5, -0.5, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,\r\n        -0.5, -0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,\r\n        -0.5, 0.5, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0 // top left \r\n    ];\r\n    const indices = [\r\n        0, 1, 3,\r\n        1, 2, 3 // second triangle\r\n    ];\r\n    let vao = gl.createVertexArray();\r\n    gl.bindVertexArray(vao);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    let ebo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(positionAttibLocation, 3, gl.FLOAT, false, 8 * 4, 0);\r\n    gl.enableVertexAttribArray(positionAttibLocation);\r\n    gl.vertexAttribPointer(colorAttribLocation, 3, gl.FLOAT, false, 8 * 4, 3 * 4);\r\n    gl.enableVertexAttribArray(colorAttribLocation);\r\n    gl.vertexAttribPointer(texCoordAttibLocation, 2, gl.FLOAT, false, 8 * 4, 6 * 4);\r\n    gl.enableVertexAttribArray(texCoordAttibLocation);\r\n    let texture1UniformLocation = gl.getUniformLocation(program, 'texture1');\r\n    let texture2UniformLocation = gl.getUniformLocation(program, 'texture2');\r\n    let images = ['./resources/images/container.jpg', './resources/images/awesomeface.jpg'];\r\n    const loadImage = function (imageSrc) {\r\n        let promise = new Promise((resolve, reject) => {\r\n            const image = new Image();\r\n            image.onload = () => {\r\n                resolve(image);\r\n            };\r\n            image.onerror = () => {\r\n                reject();\r\n            };\r\n            image.src = imageSrc;\r\n        });\r\n        return promise;\r\n    };\r\n    Promise.all(images.map(i => loadImage(i))).then(images => {\r\n        render(images);\r\n    });\r\n    function render(images) {\r\n        let textures = [];\r\n        for (let i = 0; i < images.length; i++) {\r\n            let image = images[i];\r\n            let texture = gl.createTexture();\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n            textures.push(texture);\r\n        }\r\n        gl.useProgram(program);\r\n        _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(canvas);\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n        gl.uniform1i(texture1UniformLocation, 0);\r\n        gl.uniform1i(texture2UniformLocation, 1);\r\n        gl.clearColor(0.2, 0.3, 0.3, 1.0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, textures[0]);\r\n        gl.activeTexture(gl.TEXTURE1);\r\n        gl.bindTexture(gl.TEXTURE_2D, textures[1]);\r\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/1.getting_started/6.textures_combine.ts?");

/***/ }),

/***/ "./src/1.getting_started/9.coordinate_system_depth.ts":
/*!************************************************************!*\
  !*** ./src/1.getting_started/9.coordinate_system_depth.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n/* harmony import */ var _resources_glm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/glm */ \"./src/resources/glm.ts\");\n\r\n\r\nconst vertexShaderSource = `#version 300 es\r\nin vec3 aPos;\r\nin vec2 aTexCoord;\r\n\r\nout vec2 TexCoord;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    gl_Position = projection * view * model * vec4(aPos, 1.0);\r\n    TexCoord = vec2(aTexCoord.x, aTexCoord.y);\r\n}`;\r\nconst fragmentShaderSource = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nin vec2 TexCoord;\r\n\r\nuniform sampler2D texture1;\r\nuniform sampler2D texture2;\r\nvoid main(){\r\n    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.querySelector('#c');\r\n    const gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let program = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createProgramFromStrings(gl, [vertexShaderSource, fragmentShaderSource]);\r\n    let positionAttibLocation = gl.getAttribLocation(program, 'aPos');\r\n    let texCoordAttibLocation = gl.getAttribLocation(program, 'aTexCoord');\r\n    const vertices = [\r\n        -0.5, -0.5, -0.5, 0.0, 0.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 1.0, 1.0,\r\n        -0.5, 0.5, 0.5, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, 1.0, 0.0,\r\n        -0.5, 0.5, -0.5, 1.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        0.5, -0.5, -0.5, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 0.0, 1.0,\r\n        0.5, -0.5, 0.5, 0.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 1.0, 1.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        -0.5, 0.5, 0.5, 0.0, 0.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0\r\n    ];\r\n    let vao = gl.createVertexArray();\r\n    gl.bindVertexArray(vao);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(positionAttibLocation, 3, gl.FLOAT, false, 5 * 4, 0);\r\n    gl.enableVertexAttribArray(positionAttibLocation);\r\n    gl.vertexAttribPointer(texCoordAttibLocation, 2, gl.FLOAT, false, 5 * 4, 3 * 4);\r\n    gl.enableVertexAttribArray(texCoordAttibLocation);\r\n    let texture1UniformLocation = gl.getUniformLocation(program, 'texture1');\r\n    let texture2UniformLocation = gl.getUniformLocation(program, 'texture2');\r\n    let modelLocation = gl.getUniformLocation(program, 'model');\r\n    let viewLocation = gl.getUniformLocation(program, 'view');\r\n    let projectionLocation = gl.getUniformLocation(program, 'projection');\r\n    let images = ['./resources/images/container.jpg', './resources/images/awesomeface.jpg'];\r\n    const loadImage = function (imageSrc) {\r\n        let promise = new Promise((resolve, reject) => {\r\n            const image = new Image();\r\n            image.onload = () => {\r\n                resolve(image);\r\n            };\r\n            image.onerror = () => {\r\n                reject();\r\n            };\r\n            image.src = imageSrc;\r\n        });\r\n        return promise;\r\n    };\r\n    Promise.all(images.map(i => loadImage(i))).then(images => {\r\n        render(images);\r\n    });\r\n    function render(images) {\r\n        let textures = [];\r\n        for (let i = 0; i < images.length; i++) {\r\n            let image = images[i];\r\n            let texture = gl.createTexture();\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n            textures.push(texture);\r\n        }\r\n        _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(canvas);\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n        gl.enable(gl.DEPTH_TEST);\r\n        gl.useProgram(program);\r\n        gl.uniform1i(texture1UniformLocation, 0);\r\n        gl.uniform1i(texture2UniformLocation, 1);\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, textures[0]);\r\n        gl.activeTexture(gl.TEXTURE1);\r\n        gl.bindTexture(gl.TEXTURE_2D, textures[1]);\r\n        requestAnimationFrame(drawScene);\r\n        function drawScene(time) {\r\n            time *= 0.001;\r\n            let model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n            let view = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n            let projection = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n            model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].axisRotate(model, [0.5, 1, 0], time);\r\n            view = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(view, 0, 0, -3);\r\n            let aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n            projection = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].perspective(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(45), aspect, 1, 2000);\r\n            gl.uniformMatrix4fv(modelLocation, false, model);\r\n            gl.uniformMatrix4fv(viewLocation, false, view);\r\n            gl.uniformMatrix4fv(projectionLocation, false, projection);\r\n            gl.clearColor(0.2, 0.3, 0.3, 1.0);\r\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n            gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            requestAnimationFrame(drawScene);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/1.getting_started/9.coordinate_system_depth.ts?");

/***/ }),

/***/ "./src/1.getting_started/a.coordinate_system_multiple.ts":
/*!***************************************************************!*\
  !*** ./src/1.getting_started/a.coordinate_system_multiple.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n/* harmony import */ var _resources_glm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/glm */ \"./src/resources/glm.ts\");\n\r\n\r\nconst vertexShaderSource = `#version 300 es\r\nin vec3 aPos;\r\nin vec2 aTexCoord;\r\n\r\nout vec2 TexCoord;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    gl_Position = projection * view * model * vec4(aPos, 1.0);\r\n    TexCoord = vec2(aTexCoord.x, aTexCoord.y);\r\n}`;\r\nconst fragmentShaderSource = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nin vec2 TexCoord;\r\n\r\nuniform sampler2D texture1;\r\nuniform sampler2D texture2;\r\nvoid main(){\r\n    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.querySelector('#c');\r\n    const gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let program = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createProgramFromStrings(gl, [vertexShaderSource, fragmentShaderSource]);\r\n    let positionAttibLocation = gl.getAttribLocation(program, 'aPos');\r\n    let texCoordAttibLocation = gl.getAttribLocation(program, 'aTexCoord');\r\n    const vertices = [\r\n        -0.5, -0.5, -0.5, 0.0, 0.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 1.0, 1.0,\r\n        -0.5, 0.5, 0.5, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, 1.0, 0.0,\r\n        -0.5, 0.5, -0.5, 1.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        0.5, -0.5, -0.5, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 0.0, 1.0,\r\n        0.5, -0.5, 0.5, 0.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 1.0, 1.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        -0.5, 0.5, 0.5, 0.0, 0.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0\r\n    ];\r\n    const cubePositions = [\r\n        [0.0, 0.0, 0.0],\r\n        [2.0, 5.0, -15.0],\r\n        [-1.5, -2.2, -2.5],\r\n        [-3.8, -2.0, -12.3],\r\n        [2.4, -0.4, -3.5],\r\n        [-1.7, 3.0, -7.5],\r\n        [1.3, -2.0, -2.5],\r\n        [1.5, 2.0, -2.5],\r\n        [1.5, 0.2, -1.5],\r\n        [-1.3, 1.0, -1.5]\r\n    ];\r\n    let vao = gl.createVertexArray();\r\n    gl.bindVertexArray(vao);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(positionAttibLocation, 3, gl.FLOAT, false, 5 * 4, 0);\r\n    gl.enableVertexAttribArray(positionAttibLocation);\r\n    gl.vertexAttribPointer(texCoordAttibLocation, 2, gl.FLOAT, false, 5 * 4, 3 * 4);\r\n    gl.enableVertexAttribArray(texCoordAttibLocation);\r\n    let texture1UniformLocation = gl.getUniformLocation(program, 'texture1');\r\n    let texture2UniformLocation = gl.getUniformLocation(program, 'texture2');\r\n    let modelLocation = gl.getUniformLocation(program, 'model');\r\n    let viewLocation = gl.getUniformLocation(program, 'view');\r\n    let projectionLocation = gl.getUniformLocation(program, 'projection');\r\n    let images = ['./resources/images/container.jpg', './resources/images/awesomeface.jpg'];\r\n    const loadImage = function (imageSrc) {\r\n        let promise = new Promise((resolve, reject) => {\r\n            const image = new Image();\r\n            image.onload = () => {\r\n                resolve(image);\r\n            };\r\n            image.onerror = () => {\r\n                reject();\r\n            };\r\n            image.src = imageSrc;\r\n        });\r\n        return promise;\r\n    };\r\n    Promise.all(images.map(i => loadImage(i))).then(images => {\r\n        render(images);\r\n    });\r\n    function render(images) {\r\n        let textures = [];\r\n        for (let i = 0; i < images.length; i++) {\r\n            let image = images[i];\r\n            let texture = gl.createTexture();\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n            textures.push(texture);\r\n        }\r\n        _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(canvas);\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n        gl.enable(gl.DEPTH_TEST);\r\n        gl.useProgram(program);\r\n        gl.uniform1i(texture1UniformLocation, 0);\r\n        gl.uniform1i(texture2UniformLocation, 1);\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, textures[0]);\r\n        gl.activeTexture(gl.TEXTURE1);\r\n        gl.bindTexture(gl.TEXTURE_2D, textures[1]);\r\n        // requestAnimationFrame(drawScene);\r\n        drawScene();\r\n        function drawScene() {\r\n            // time *= 0.001;\r\n            let view = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n            let projection = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n            view = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(view, 0, 0, -3);\r\n            let aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n            projection = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].perspective(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(45), aspect, 1, 2000);\r\n            gl.uniformMatrix4fv(viewLocation, false, view);\r\n            gl.uniformMatrix4fv(projectionLocation, false, projection);\r\n            gl.clearColor(0.2, 0.3, 0.3, 1.0);\r\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n            for (let i = 0; i < cubePositions.length; i++) {\r\n                let model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(model, cubePositions[i]);\r\n                let angle = 20 * i;\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].axisRotate(model, [1, 0.3, 0.5], _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(angle));\r\n                gl.uniformMatrix4fv(modelLocation, false, model);\r\n                gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            }\r\n            // requestAnimationFrame(drawScene);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/1.getting_started/a.coordinate_system_multiple.ts?");

/***/ }),

/***/ "./src/1.getting_started/b.camera_circle.ts":
/*!**************************************************!*\
  !*** ./src/1.getting_started/b.camera_circle.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n/* harmony import */ var _resources_glm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/glm */ \"./src/resources/glm.ts\");\n\r\n\r\nconst vertexShaderSource = `#version 300 es\r\nin vec3 aPos;\r\nin vec2 aTexCoord;\r\n\r\nout vec2 TexCoord;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    gl_Position = projection * view * model * vec4(aPos.x, (-1.0) * aPos.y, aPos.z, 1.0);\r\n    TexCoord = vec2(aTexCoord.x, aTexCoord.y);\r\n}`;\r\nconst fragmentShaderSource = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nin vec2 TexCoord;\r\n\r\nuniform sampler2D texture1;\r\nuniform sampler2D texture2;\r\nvoid main(){\r\n    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.querySelector('#c');\r\n    const gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let program = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createProgramFromStrings(gl, [vertexShaderSource, fragmentShaderSource]);\r\n    let positionAttibLocation = gl.getAttribLocation(program, 'aPos');\r\n    let texCoordAttibLocation = gl.getAttribLocation(program, 'aTexCoord');\r\n    const vertices = [\r\n        -0.5, -0.5, -0.5, 0.0, 0.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 1.0, 1.0,\r\n        -0.5, 0.5, 0.5, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, 1.0, 0.0,\r\n        -0.5, 0.5, -0.5, 1.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        0.5, -0.5, -0.5, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 0.0, 1.0,\r\n        0.5, -0.5, 0.5, 0.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 1.0, 1.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        -0.5, 0.5, 0.5, 0.0, 0.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0\r\n    ];\r\n    const cubePositions = [\r\n        [0.0, 0.0, 0.0],\r\n        [2.0, 5.0, -15.0],\r\n        [-1.5, -2.2, -2.5],\r\n        [-3.8, -2.0, -12.3],\r\n        [2.4, -0.4, -3.5],\r\n        [-1.7, 3.0, -7.5],\r\n        [1.3, -2.0, -2.5],\r\n        [1.5, 2.0, -2.5],\r\n        [1.5, 0.2, -1.5],\r\n        [-1.3, 1.0, -1.5]\r\n    ];\r\n    let vao = gl.createVertexArray();\r\n    gl.bindVertexArray(vao);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(positionAttibLocation, 3, gl.FLOAT, false, 5 * 4, 0);\r\n    gl.enableVertexAttribArray(positionAttibLocation);\r\n    gl.vertexAttribPointer(texCoordAttibLocation, 2, gl.FLOAT, false, 5 * 4, 3 * 4);\r\n    gl.enableVertexAttribArray(texCoordAttibLocation);\r\n    let texture1UniformLocation = gl.getUniformLocation(program, 'texture1');\r\n    let texture2UniformLocation = gl.getUniformLocation(program, 'texture2');\r\n    let modelLocation = gl.getUniformLocation(program, 'model');\r\n    let viewLocation = gl.getUniformLocation(program, 'view');\r\n    let projectionLocation = gl.getUniformLocation(program, 'projection');\r\n    let images = ['./resources/images/container.jpg', './resources/images/awesomeface.jpg'];\r\n    const loadImage = function (imageSrc) {\r\n        let promise = new Promise((resolve, reject) => {\r\n            const image = new Image();\r\n            image.onload = () => {\r\n                resolve(image);\r\n            };\r\n            image.onerror = () => {\r\n                reject();\r\n            };\r\n            image.src = imageSrc;\r\n        });\r\n        return promise;\r\n    };\r\n    Promise.all(images.map(i => loadImage(i))).then(images => {\r\n        render(images);\r\n    });\r\n    function render(images) {\r\n        let textures = [];\r\n        for (let i = 0; i < images.length; i++) {\r\n            let image = images[i];\r\n            let texture = gl.createTexture();\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n            textures.push(texture);\r\n        }\r\n        _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(canvas);\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n        gl.enable(gl.DEPTH_TEST);\r\n        gl.useProgram(program);\r\n        gl.uniform1i(texture1UniformLocation, 0);\r\n        gl.uniform1i(texture2UniformLocation, 1);\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, textures[0]);\r\n        gl.activeTexture(gl.TEXTURE1);\r\n        gl.bindTexture(gl.TEXTURE_2D, textures[1]);\r\n        requestAnimationFrame(drawScene);\r\n        function drawScene(time) {\r\n            time *= 0.001;\r\n            let radius = 10.0;\r\n            let camX = Math.sin(time) * radius;\r\n            let camZ = Math.cos(time) * radius;\r\n            let camera = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lookAt([camX, 0, camZ], [0, 0, 0], [0, 1, 0]);\r\n            let view = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].inverse(camera);\r\n            let aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n            let projection = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].perspective(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(45), aspect, 1, 2000);\r\n            gl.uniformMatrix4fv(viewLocation, false, view);\r\n            gl.uniformMatrix4fv(projectionLocation, false, projection);\r\n            gl.clearColor(0.2, 0.3, 0.3, 1.0);\r\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n            for (let i = 0; i < cubePositions.length; i++) {\r\n                let model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(model, cubePositions[i]);\r\n                let angle = 20 * i;\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].axisRotate(model, [1, 0.3, 0.5], _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(angle));\r\n                gl.uniformMatrix4fv(modelLocation, false, model);\r\n                gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            }\r\n            requestAnimationFrame(drawScene);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/1.getting_started/b.camera_circle.ts?");

/***/ }),

/***/ "./src/1.getting_started/c.camera_keyboard_dt.ts":
/*!*******************************************************!*\
  !*** ./src/1.getting_started/c.camera_keyboard_dt.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n/* harmony import */ var _resources_glm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/glm */ \"./src/resources/glm.ts\");\n\r\n\r\nconst vertexShaderSource = `#version 300 es\r\nin vec3 aPos;\r\nin vec2 aTexCoord;\r\n\r\nout vec2 TexCoord;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    gl_Position = projection * view * model * vec4(aPos.x, (-1.0) * aPos.y, aPos.z, 1.0);\r\n    TexCoord = vec2(aTexCoord.x, aTexCoord.y);\r\n}`;\r\nconst fragmentShaderSource = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nin vec2 TexCoord;\r\n\r\nuniform sampler2D texture1;\r\nuniform sampler2D texture2;\r\nvoid main(){\r\n    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);\r\n}`;\r\nfunction main() {\r\n    let images = ['./resources/images/container.jpg', './resources/images/awesomeface.jpg'];\r\n    const loadImage = function (imageSrc) {\r\n        let promise = new Promise((resolve, reject) => {\r\n            const image = new Image();\r\n            image.onload = () => {\r\n                resolve(image);\r\n            };\r\n            image.onerror = () => {\r\n                reject();\r\n            };\r\n            image.src = imageSrc;\r\n        });\r\n        return promise;\r\n    };\r\n    Promise.all(images.map(i => loadImage(i))).then(images => {\r\n        render(images);\r\n    });\r\n}\r\nfunction render(images) {\r\n    const canvas = document.querySelector('#c');\r\n    const gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let cameraPosition = [0, 0, 3];\r\n    let cameraFront = [0, 0, -1];\r\n    let cameraUp = [0, 1, 0];\r\n    let deltaTime = 0;\r\n    let lastFrame = 0;\r\n    let program = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createProgramFromStrings(gl, [vertexShaderSource, fragmentShaderSource]);\r\n    let positionAttibLocation = gl.getAttribLocation(program, 'aPos');\r\n    let texCoordAttibLocation = gl.getAttribLocation(program, 'aTexCoord');\r\n    const vertices = [\r\n        -0.5, -0.5, -0.5, 0.0, 0.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 1.0, 1.0,\r\n        -0.5, 0.5, 0.5, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, 1.0, 0.0,\r\n        -0.5, 0.5, -0.5, 1.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        0.5, -0.5, -0.5, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 0.0, 1.0,\r\n        0.5, -0.5, 0.5, 0.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 1.0, 1.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        -0.5, 0.5, 0.5, 0.0, 0.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0\r\n    ];\r\n    const cubePositions = [\r\n        [0.0, 0.0, 0.0],\r\n        [2.0, 5.0, -15.0],\r\n        [-1.5, -2.2, -2.5],\r\n        [-3.8, -2.0, -12.3],\r\n        [2.4, -0.4, -3.5],\r\n        [-1.7, 3.0, -7.5],\r\n        [1.3, -2.0, -2.5],\r\n        [1.5, 2.0, -2.5],\r\n        [1.5, 0.2, -1.5],\r\n        [-1.3, 1.0, -1.5]\r\n    ];\r\n    let vao = gl.createVertexArray();\r\n    gl.bindVertexArray(vao);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(positionAttibLocation, 3, gl.FLOAT, false, 5 * 4, 0);\r\n    gl.enableVertexAttribArray(positionAttibLocation);\r\n    gl.vertexAttribPointer(texCoordAttibLocation, 2, gl.FLOAT, false, 5 * 4, 3 * 4);\r\n    gl.enableVertexAttribArray(texCoordAttibLocation);\r\n    let texture1UniformLocation = gl.getUniformLocation(program, 'texture1');\r\n    let texture2UniformLocation = gl.getUniformLocation(program, 'texture2');\r\n    let modelLocation = gl.getUniformLocation(program, 'model');\r\n    let viewLocation = gl.getUniformLocation(program, 'view');\r\n    let projectionLocation = gl.getUniformLocation(program, 'projection');\r\n    let textures = [];\r\n    for (let i = 0; i < images.length; i++) {\r\n        let image = images[i];\r\n        let texture = gl.createTexture();\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n        gl.generateMipmap(gl.TEXTURE_2D);\r\n        textures.push(texture);\r\n    }\r\n    _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(canvas);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    gl.useProgram(program);\r\n    gl.uniform1i(texture1UniformLocation, 0);\r\n    gl.uniform1i(texture2UniformLocation, 1);\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_2D, textures[0]);\r\n    gl.activeTexture(gl.TEXTURE1);\r\n    gl.bindTexture(gl.TEXTURE_2D, textures[1]);\r\n    function getTime(time) {\r\n        let currentFrame = time;\r\n        deltaTime = (currentFrame - lastFrame) * 0.001;\r\n        lastFrame = currentFrame;\r\n        requestAnimationFrame(getTime);\r\n    }\r\n    drawScene();\r\n    requestAnimationFrame(getTime);\r\n    function drawScene() {\r\n        let center = [cameraPosition[0] + cameraFront[0], cameraPosition[1] + cameraFront[1], cameraPosition[2] + cameraFront[2]];\r\n        let camera = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lookAt(cameraPosition, center, cameraUp);\r\n        let view = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].inverse(camera);\r\n        let aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n        let projection = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].perspective(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(45), aspect, 1, 2000);\r\n        gl.uniformMatrix4fv(viewLocation, false, view);\r\n        gl.uniformMatrix4fv(projectionLocation, false, projection);\r\n        gl.clearColor(0.2, 0.3, 0.3, 1.0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        for (let i = 0; i < cubePositions.length; i++) {\r\n            let model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n            model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(model, cubePositions[i]);\r\n            let angle = 20 * i;\r\n            model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].axisRotate(model, [1, 0.3, 0.5], _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(angle));\r\n            gl.uniformMatrix4fv(modelLocation, false, model);\r\n            gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n        }\r\n    }\r\n    document.onkeydown = (event) => {\r\n        var e = event || window.event || arguments.callee.caller.arguments[0];\r\n        let cameraSpeed = 2.5 * deltaTime;\r\n        if (e && e.keyCode == 87) { // 按 W \r\n            cameraPosition[0] += cameraSpeed * cameraFront[0];\r\n            cameraPosition[1] += cameraSpeed * cameraFront[1];\r\n            cameraPosition[2] += cameraSpeed * cameraFront[2];\r\n            // console.log('wwwww');\r\n        }\r\n        else if (e && e.keyCode == 83) { // 按 S \r\n            cameraPosition[0] -= cameraSpeed * cameraFront[0];\r\n            cameraPosition[1] -= cameraSpeed * cameraFront[1];\r\n            cameraPosition[2] -= cameraSpeed * cameraFront[2];\r\n            // console.log('sssss');\r\n        }\r\n        else if (e && e.keyCode == 65) { // A\r\n            // console.log('aaaaa');\r\n            cameraPosition[0] -= _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cross(cameraFront, cameraUp))[0] * cameraSpeed;\r\n            cameraPosition[1] -= _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cross(cameraFront, cameraUp))[1] * cameraSpeed;\r\n            cameraPosition[2] -= _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cross(cameraFront, cameraUp))[2] * cameraSpeed;\r\n        }\r\n        else if (e && e.keyCode == 68) { // D\r\n            // console.log('ddddd');\r\n            cameraPosition[0] += _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cross(cameraFront, cameraUp))[0] * cameraSpeed;\r\n            cameraPosition[1] += _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cross(cameraFront, cameraUp))[1] * cameraSpeed;\r\n            cameraPosition[2] += _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cross(cameraFront, cameraUp))[2] * cameraSpeed;\r\n        }\r\n        drawScene();\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/1.getting_started/c.camera_keyboard_dt.ts?");

/***/ }),

/***/ "./src/1.getting_started/d.camera_mouse_zoom.ts":
/*!******************************************************!*\
  !*** ./src/1.getting_started/d.camera_mouse_zoom.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n/* harmony import */ var _resources_glm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/glm */ \"./src/resources/glm.ts\");\n\r\n\r\nconst vertexShaderSource = `#version 300 es\r\nin vec3 aPos;\r\nin vec2 aTexCoord;\r\n\r\nout vec2 TexCoord;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    gl_Position = projection * view * model * vec4(aPos.x, (-1.0) * aPos.y, aPos.z, 1.0);\r\n    TexCoord = vec2(aTexCoord.x, aTexCoord.y);\r\n}`;\r\nconst fragmentShaderSource = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nin vec2 TexCoord;\r\n\r\nuniform sampler2D texture1;\r\nuniform sampler2D texture2;\r\nvoid main(){\r\n    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);\r\n}`;\r\nfunction main() {\r\n    let images = ['./resources/images/container.jpg', './resources/images/awesomeface.jpg'];\r\n    const loadImage = function (imageSrc) {\r\n        let promise = new Promise((resolve, reject) => {\r\n            const image = new Image();\r\n            image.onload = () => {\r\n                resolve(image);\r\n            };\r\n            image.onerror = () => {\r\n                reject();\r\n            };\r\n            image.src = imageSrc;\r\n        });\r\n        return promise;\r\n    };\r\n    Promise.all(images.map(i => loadImage(i))).then(images => {\r\n        render(images);\r\n    });\r\n}\r\nfunction render(images) {\r\n    const canvas = document.querySelector('#c');\r\n    const gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let cameraPosition = [0, 0, 3];\r\n    let cameraFront = [0, 0, -1];\r\n    let cameraUp = [0, 1, 0];\r\n    let deltaTime = 0;\r\n    let lastFrame = 0;\r\n    let lastX, lastY;\r\n    let yaw = -90;\r\n    let pitch = 0;\r\n    let fov = 45;\r\n    let program = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createProgramFromStrings(gl, [vertexShaderSource, fragmentShaderSource]);\r\n    let positionAttibLocation = gl.getAttribLocation(program, 'aPos');\r\n    let texCoordAttibLocation = gl.getAttribLocation(program, 'aTexCoord');\r\n    const vertices = [\r\n        -0.5, -0.5, -0.5, 0.0, 0.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 1.0, 1.0,\r\n        -0.5, 0.5, 0.5, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, 1.0, 0.0,\r\n        -0.5, 0.5, -0.5, 1.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        0.5, -0.5, -0.5, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 0.0, 1.0,\r\n        0.5, -0.5, 0.5, 0.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 1.0, 1.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0,\r\n        0.5, 0.5, -0.5, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0,\r\n        -0.5, 0.5, 0.5, 0.0, 0.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0\r\n    ];\r\n    const cubePositions = [\r\n        [0.0, 0.0, 0.0],\r\n        [2.0, 5.0, -15.0],\r\n        [-1.5, -2.2, -2.5],\r\n        [-3.8, -2.0, -12.3],\r\n        [2.4, -0.4, -3.5],\r\n        [-1.7, 3.0, -7.5],\r\n        [1.3, -2.0, -2.5],\r\n        [1.5, 2.0, -2.5],\r\n        [1.5, 0.2, -1.5],\r\n        [-1.3, 1.0, -1.5]\r\n    ];\r\n    let vao = gl.createVertexArray();\r\n    gl.bindVertexArray(vao);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(positionAttibLocation, 3, gl.FLOAT, false, 5 * 4, 0);\r\n    gl.enableVertexAttribArray(positionAttibLocation);\r\n    gl.vertexAttribPointer(texCoordAttibLocation, 2, gl.FLOAT, false, 5 * 4, 3 * 4);\r\n    gl.enableVertexAttribArray(texCoordAttibLocation);\r\n    let texture1UniformLocation = gl.getUniformLocation(program, 'texture1');\r\n    let texture2UniformLocation = gl.getUniformLocation(program, 'texture2');\r\n    let modelLocation = gl.getUniformLocation(program, 'model');\r\n    let viewLocation = gl.getUniformLocation(program, 'view');\r\n    let projectionLocation = gl.getUniformLocation(program, 'projection');\r\n    let textures = [];\r\n    for (let i = 0; i < images.length; i++) {\r\n        let image = images[i];\r\n        let texture = gl.createTexture();\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n        gl.generateMipmap(gl.TEXTURE_2D);\r\n        textures.push(texture);\r\n    }\r\n    _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(canvas);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    gl.useProgram(program);\r\n    gl.uniform1i(texture1UniformLocation, 0);\r\n    gl.uniform1i(texture2UniformLocation, 1);\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_2D, textures[0]);\r\n    gl.activeTexture(gl.TEXTURE1);\r\n    gl.bindTexture(gl.TEXTURE_2D, textures[1]);\r\n    function getTime(time) {\r\n        let currentFrame = time;\r\n        deltaTime = (currentFrame - lastFrame) * 0.001;\r\n        lastFrame = currentFrame;\r\n        requestAnimationFrame(getTime);\r\n    }\r\n    drawScene();\r\n    requestAnimationFrame(getTime);\r\n    function drawScene() {\r\n        let center = [cameraPosition[0] + cameraFront[0], cameraPosition[1] + cameraFront[1], cameraPosition[2] + cameraFront[2]];\r\n        let camera = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lookAt(cameraPosition, center, cameraUp);\r\n        let view = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].inverse(camera);\r\n        let aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n        let projection = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].perspective(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(fov), aspect, 1, 2000);\r\n        gl.uniformMatrix4fv(viewLocation, false, view);\r\n        gl.uniformMatrix4fv(projectionLocation, false, projection);\r\n        gl.clearColor(0.2, 0.3, 0.3, 1.0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        for (let i = 0; i < cubePositions.length; i++) {\r\n            let model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n            model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(model, cubePositions[i]);\r\n            let angle = 20 * i;\r\n            model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].axisRotate(model, [1, 0.3, 0.5], _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(angle));\r\n            gl.uniformMatrix4fv(modelLocation, false, model);\r\n            gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n        }\r\n    }\r\n    document.onkeydown = (event) => {\r\n        var e = event || window.event || arguments.callee.caller.arguments[0];\r\n        let cameraSpeed = 2.5 * deltaTime;\r\n        if (e && e.keyCode == 87) { // 按 W \r\n            cameraPosition[0] += cameraSpeed * cameraFront[0];\r\n            cameraPosition[1] += cameraSpeed * cameraFront[1];\r\n            cameraPosition[2] += cameraSpeed * cameraFront[2];\r\n            // console.log('wwwww');\r\n        }\r\n        else if (e && e.keyCode == 83) { // 按 S \r\n            cameraPosition[0] -= cameraSpeed * cameraFront[0];\r\n            cameraPosition[1] -= cameraSpeed * cameraFront[1];\r\n            cameraPosition[2] -= cameraSpeed * cameraFront[2];\r\n            // console.log('sssss');\r\n        }\r\n        else if (e && e.keyCode == 65) { // A\r\n            // console.log('aaaaa');\r\n            cameraPosition[0] -= _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cross(cameraFront, cameraUp))[0] * cameraSpeed;\r\n            cameraPosition[1] -= _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cross(cameraFront, cameraUp))[1] * cameraSpeed;\r\n            cameraPosition[2] -= _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cross(cameraFront, cameraUp))[2] * cameraSpeed;\r\n        }\r\n        else if (e && e.keyCode == 68) { // D\r\n            // console.log('ddddd');\r\n            cameraPosition[0] += _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cross(cameraFront, cameraUp))[0] * cameraSpeed;\r\n            cameraPosition[1] += _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cross(cameraFront, cameraUp))[1] * cameraSpeed;\r\n            cameraPosition[2] += _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cross(cameraFront, cameraUp))[2] * cameraSpeed;\r\n        }\r\n        drawScene();\r\n    };\r\n    canvas.onmousedown = (e) => {\r\n        lastX = e.clientX;\r\n        lastY = e.clientY;\r\n        fndown();\r\n    };\r\n    function fndown() {\r\n        canvas.onmousemove = (e) => {\r\n            let offsetX = e.clientX - lastX;\r\n            let offsetY = lastY - e.clientY;\r\n            lastX = e.clientX;\r\n            lastY = e.clientY;\r\n            let sensitivity = 0.1;\r\n            offsetX *= sensitivity;\r\n            offsetY *= sensitivity;\r\n            yaw += offsetX;\r\n            pitch += offsetY;\r\n            let x = Math.cos(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(yaw)) * Math.cos(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(pitch));\r\n            let y = Math.sin(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(pitch));\r\n            let z = Math.sin(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(yaw)) * Math.cos(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(pitch));\r\n            cameraFront = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize([x, y, z]);\r\n            drawScene();\r\n            console.log(\"ondrag\");\r\n        };\r\n        canvas.onmouseup = (e) => {\r\n            canvas.onmousemove = null;\r\n            console.log(\"up\");\r\n        };\r\n    }\r\n    canvas.onwheel = (e) => {\r\n        let offsetY = e.deltaY * 0.1;\r\n        if (fov >= 1.0 && fov <= 45.0)\r\n            fov += offsetY;\r\n        if (fov <= 1.0)\r\n            fov = 1.0;\r\n        if (fov >= 45.0)\r\n            fov = 45.0;\r\n        drawScene();\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/1.getting_started/d.camera_mouse_zoom.ts?");

/***/ }),

/***/ "./src/2.lighting/01.colors.ts":
/*!*************************************!*\
  !*** ./src/2.lighting/01.colors.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n/* harmony import */ var _resources_glm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/glm */ \"./src/resources/glm.ts\");\n\r\n\r\nconst vertexShaderColorSource = `#version 300 es\r\nin vec3 aPos;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    gl_Position = projection * view * model * vec4(aPos * vec3(1, -1, 1), 1.0);\r\n}`;\r\nconst fragmentShaderColorSource = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nuniform vec3 u_objectColor;\r\nuniform vec3 u_lightColor;\r\nvoid main(){\r\n    FragColor = vec4(u_lightColor * u_objectColor, 1);\r\n}`;\r\nconst vertexShaderLampSource = `#version 300 es\r\nin vec3 aPos;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    gl_Position = projection * view * model * vec4(aPos * vec3(1, -1, 1), 1);\r\n    \r\n}`;\r\nconst fragmentShaderLampSource = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nvoid main(){\r\n    FragColor = vec4(1);\r\n\r\n}`;\r\nfunction main() {\r\n    const canvas = document.querySelector('#c');\r\n    const gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let cameraPosition = [0, 0, 3];\r\n    let cameraFront = [0, 0, -1];\r\n    let cameraUp = [0, 1, 0];\r\n    let deltaTime = 0;\r\n    let lastFrame = 0;\r\n    let lastX, lastY;\r\n    let yaw = -90;\r\n    let pitch = 0;\r\n    let fov = 45;\r\n    let lightPos = [1.2, 1, 2];\r\n    let lightingProgram = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createProgramFromStrings(gl, [vertexShaderColorSource, fragmentShaderColorSource]);\r\n    let lampProgram = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createProgramFromStrings(gl, [vertexShaderLampSource, fragmentShaderLampSource]);\r\n    let lightingPositionAttibLocation = gl.getAttribLocation(lightingProgram, 'aPos');\r\n    let objectColorLocation = gl.getUniformLocation(lightingProgram, 'u_objectColor');\r\n    let lightColorLocation = gl.getUniformLocation(lightingProgram, 'u_lightColor');\r\n    let lightingModelLocation = gl.getUniformLocation(lightingProgram, 'model');\r\n    let lightingViewLocation = gl.getUniformLocation(lightingProgram, 'view');\r\n    let lightingProjectionLocation = gl.getUniformLocation(lightingProgram, 'projection');\r\n    let lampPositionAttibLocation = gl.getAttribLocation(lampProgram, 'aPos');\r\n    let lampModelLocation = gl.getUniformLocation(lampProgram, 'model');\r\n    let lampViewLocation = gl.getUniformLocation(lampProgram, 'view');\r\n    let lampProjectionLocation = gl.getUniformLocation(lampProgram, 'projection');\r\n    const vertices = [\r\n        -0.5, -0.5, -0.5,\r\n        0.5, -0.5, -0.5,\r\n        0.5, 0.5, -0.5,\r\n        0.5, 0.5, -0.5,\r\n        -0.5, 0.5, -0.5,\r\n        -0.5, -0.5, -0.5,\r\n        -0.5, -0.5, 0.5,\r\n        0.5, -0.5, 0.5,\r\n        0.5, 0.5, 0.5,\r\n        0.5, 0.5, 0.5,\r\n        -0.5, 0.5, 0.5,\r\n        -0.5, -0.5, 0.5,\r\n        -0.5, 0.5, 0.5,\r\n        -0.5, 0.5, -0.5,\r\n        -0.5, -0.5, -0.5,\r\n        -0.5, -0.5, -0.5,\r\n        -0.5, -0.5, 0.5,\r\n        -0.5, 0.5, 0.5,\r\n        0.5, 0.5, 0.5,\r\n        0.5, 0.5, -0.5,\r\n        0.5, -0.5, -0.5,\r\n        0.5, -0.5, -0.5,\r\n        0.5, -0.5, 0.5,\r\n        0.5, 0.5, 0.5,\r\n        -0.5, -0.5, -0.5,\r\n        0.5, -0.5, -0.5,\r\n        0.5, -0.5, 0.5,\r\n        0.5, -0.5, 0.5,\r\n        -0.5, -0.5, 0.5,\r\n        -0.5, -0.5, -0.5,\r\n        -0.5, 0.5, -0.5,\r\n        0.5, 0.5, -0.5,\r\n        0.5, 0.5, 0.5,\r\n        0.5, 0.5, 0.5,\r\n        -0.5, 0.5, 0.5,\r\n        -0.5, 0.5, -0.5,\r\n    ];\r\n    let vao = gl.createVertexArray();\r\n    gl.bindVertexArray(vao);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(lightingPositionAttibLocation, 3, gl.FLOAT, false, 3 * 4, 0);\r\n    gl.enableVertexAttribArray(lightingPositionAttibLocation);\r\n    gl.vertexAttribPointer(lampPositionAttibLocation, 3, gl.FLOAT, false, 3 * 4, 0);\r\n    gl.enableVertexAttribArray(lampPositionAttibLocation);\r\n    _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(canvas);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    gl.useProgram(lightingProgram);\r\n    gl.uniform3fv(objectColorLocation, [1.0, 0.5, 0.31]);\r\n    gl.uniform3fv(lightColorLocation, [1.0, 1.0, 1.0]);\r\n    function getTime(time) {\r\n        let currentFrame = time;\r\n        deltaTime = (currentFrame - lastFrame) * 0.001;\r\n        lastFrame = currentFrame;\r\n        requestAnimationFrame(getTime);\r\n    }\r\n    drawScene();\r\n    requestAnimationFrame(getTime);\r\n    function drawScene() {\r\n        gl.clearColor(0.1, 0.1, 0.1, 1.0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        gl.useProgram(lightingProgram);\r\n        let center = [cameraPosition[0] + cameraFront[0], cameraPosition[1] + cameraFront[1], cameraPosition[2] + cameraFront[2]];\r\n        let camera = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lookAt(cameraPosition, center, cameraUp);\r\n        let view = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].inverse(camera);\r\n        gl.uniformMatrix4fv(lightingViewLocation, false, view);\r\n        let glcanvas = gl.canvas;\r\n        let aspect = glcanvas.clientWidth / glcanvas.clientHeight;\r\n        let projection = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].perspective(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(fov), aspect, 0.1, 100);\r\n        gl.uniformMatrix4fv(lightingProjectionLocation, false, projection);\r\n        let model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n        gl.uniformMatrix4fv(lightingModelLocation, false, model);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n        gl.useProgram(lampProgram);\r\n        gl.uniformMatrix4fv(lampProjectionLocation, false, projection);\r\n        gl.uniformMatrix4fv(lampViewLocation, false, view);\r\n        model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(model, lightPos);\r\n        model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].scale(model, 0.2, 0.2, 0.2);\r\n        gl.uniformMatrix4fv(lampModelLocation, false, model);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n    }\r\n    document.onkeydown = (event) => {\r\n        var e = event || window.event || arguments.callee.caller.arguments[0];\r\n        let cameraSpeed = 2.5 * deltaTime;\r\n        if (e && e.keyCode == 87) { // 按 W \r\n            cameraPosition[0] += cameraSpeed * cameraFront[0];\r\n            cameraPosition[1] += cameraSpeed * cameraFront[1];\r\n            cameraPosition[2] += cameraSpeed * cameraFront[2];\r\n            // console.log('wwwww');\r\n        }\r\n        else if (e && e.keyCode == 83) { // 按 S \r\n            cameraPosition[0] -= cameraSpeed * cameraFront[0];\r\n            cameraPosition[1] -= cameraSpeed * cameraFront[1];\r\n            cameraPosition[2] -= cameraSpeed * cameraFront[2];\r\n            // console.log('sssss');\r\n        }\r\n        else if (e && e.keyCode == 65) { // A\r\n            // console.log('aaaaa');\r\n            cameraPosition[0] -= _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cross(cameraFront, cameraUp))[0] * cameraSpeed;\r\n            cameraPosition[1] -= _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cross(cameraFront, cameraUp))[1] * cameraSpeed;\r\n            cameraPosition[2] -= _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cross(cameraFront, cameraUp))[2] * cameraSpeed;\r\n        }\r\n        else if (e && e.keyCode == 68) { // D\r\n            // console.log('ddddd');\r\n            cameraPosition[0] += _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cross(cameraFront, cameraUp))[0] * cameraSpeed;\r\n            cameraPosition[1] += _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cross(cameraFront, cameraUp))[1] * cameraSpeed;\r\n            cameraPosition[2] += _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cross(cameraFront, cameraUp))[2] * cameraSpeed;\r\n        }\r\n        drawScene();\r\n    };\r\n    canvas.onmousedown = (e) => {\r\n        lastX = e.clientX;\r\n        lastY = e.clientY;\r\n        fndown();\r\n    };\r\n    function fndown() {\r\n        canvas.onmousemove = (e) => {\r\n            let offsetX = e.clientX - lastX;\r\n            let offsetY = lastY - e.clientY;\r\n            lastX = e.clientX;\r\n            lastY = e.clientY;\r\n            let sensitivity = 0.1;\r\n            offsetX *= sensitivity;\r\n            offsetY *= sensitivity;\r\n            yaw += offsetX;\r\n            pitch += offsetY;\r\n            let x = Math.cos(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(yaw)) * Math.cos(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(pitch));\r\n            let y = Math.sin(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(pitch));\r\n            let z = Math.sin(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(yaw)) * Math.cos(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(pitch));\r\n            cameraFront = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].normalize([x, y, z]);\r\n            drawScene();\r\n            console.log(\"ondrag\");\r\n        };\r\n        canvas.onmouseup = (e) => {\r\n            canvas.onmousemove = null;\r\n            console.log(\"up\");\r\n        };\r\n    }\r\n    canvas.onwheel = (e) => {\r\n        let offsetY = e.deltaY * 0.1;\r\n        if (fov >= 1.0 && fov <= 45.0)\r\n            fov += offsetY;\r\n        if (fov <= 1.0)\r\n            fov = 1.0;\r\n        if (fov >= 45.0)\r\n            fov = 45.0;\r\n        drawScene();\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/2.lighting/01.colors.ts?");

/***/ }),

/***/ "./src/2.lighting/02.basic_lighting_diffuse.ts":
/*!*****************************************************!*\
  !*** ./src/2.lighting/02.basic_lighting_diffuse.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n/* harmony import */ var _resources_glm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/glm */ \"./src/resources/glm.ts\");\n/* harmony import */ var _resources_camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/camera */ \"./src/resources/camera.ts\");\n\r\n\r\n\r\nconst vsBasicLighting = `#version 300 es\r\nin vec3 aPos;\r\nin vec3 aNormal;\r\n\r\nout vec3 FragPos;\r\nout vec3 Normal;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    FragPos = vec3(model * vec4(aPos, 1.0));\r\n    Normal = aNormal;\r\n\r\n    gl_Position = projection * view * vec4(FragPos, 1.0);\r\n}`;\r\nconst fsBasicLighting = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nin vec3 Normal;\r\nin vec3 FragPos;\r\n\r\nuniform vec3 lightPos;\r\nuniform vec3 objectColor;\r\nuniform vec3 lightColor;\r\nvoid main(){\r\n    // ambient\r\n    float ambientStrengh = 0.1;\r\n    vec3 ambient = ambientStrengh * lightColor;\r\n\r\n    // diffuse\r\n    vec3 norm = normalize(Normal);\r\n    vec3 lightDir = normalize(lightPos - FragPos);\r\n    float diff = max(dot(norm, lightDir), 0.0);\r\n    vec3 diffuse = diff * lightColor;\r\n\r\n    vec3 result = (ambient + diffuse) * objectColor;\r\n    FragColor = vec4(result, 1.0);\r\n}`;\r\nconst vsLightCube = `#version 300 es\r\nin vec3 aPos;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    gl_Position = projection * view * model * vec4(aPos, 1.0);\r\n    \r\n}`;\r\nconst fsLightCube = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nvoid main(){\r\n    FragColor = vec4(1.0);\r\n\r\n}`;\r\nfunction main() {\r\n    const canvas = document.querySelector('#c');\r\n    const gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let camera = new _resources_camera__WEBPACK_IMPORTED_MODULE_2__[\"default\"]([0, 0, 3]);\r\n    // let cameraPosition = [0, 0, 3];\r\n    // let cameraFront:Vector3 = [0, 0, -1];\r\n    // let cameraUp = [0, 1, 0];\r\n    let deltaTime = 0;\r\n    let lastFrame = 0;\r\n    let lastX, lastY;\r\n    // let yaw = -90;\r\n    // let pitch = 0;\r\n    // let fov = 45;\r\n    let firstMouse = true;\r\n    let lightPos = [1.2, 1, 2];\r\n    let lightingProgram = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createProgramFromStrings(gl, [vsBasicLighting, fsBasicLighting]);\r\n    let lampProgram = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createProgramFromStrings(gl, [vsLightCube, fsLightCube]);\r\n    let lightingPositionAttibLocation = gl.getAttribLocation(lightingProgram, 'aPos');\r\n    let lightingNormalAttibLocation = gl.getAttribLocation(lightingProgram, 'aNormal');\r\n    let lightPosLocation = gl.getUniformLocation(lightingProgram, 'lightPos');\r\n    let objectColorLocation = gl.getUniformLocation(lightingProgram, 'objectColor');\r\n    let lightColorLocation = gl.getUniformLocation(lightingProgram, 'lightColor');\r\n    let lightingModelLocation = gl.getUniformLocation(lightingProgram, 'model');\r\n    let lightingViewLocation = gl.getUniformLocation(lightingProgram, 'view');\r\n    let lightingProjectionLocation = gl.getUniformLocation(lightingProgram, 'projection');\r\n    let lampPositionAttibLocation = gl.getAttribLocation(lampProgram, 'aPos');\r\n    let lampModelLocation = gl.getUniformLocation(lampProgram, 'model');\r\n    let lampViewLocation = gl.getUniformLocation(lampProgram, 'view');\r\n    let lampProjectionLocation = gl.getUniformLocation(lampProgram, 'projection');\r\n    const vertices = [\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0,\r\n        0.5, -0.5, -0.5, 0.0, 0.0, -1.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 0.0, -1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, 0.5, 0.0, 0.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0,\r\n        -0.5, 0.5, 0.5, 0.0, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0,\r\n        -0.5, 0.5, -0.5, -1.0, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0,\r\n        -0.5, -0.5, 0.5, -1.0, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 0.0, 0.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0,\r\n        0.5, -0.5, -0.5, 0.0, -1.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, -1.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, 0.5, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0\r\n    ];\r\n    // first, configure the cube's VAO (and VBO)\r\n    let cubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(cubeVAO);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(lightingPositionAttibLocation, 3, gl.FLOAT, false, 6 * 4, 0);\r\n    gl.enableVertexAttribArray(lightingPositionAttibLocation);\r\n    gl.vertexAttribPointer(lightingNormalAttibLocation, 3, gl.FLOAT, false, 6 * 4, 3 * 4);\r\n    gl.enableVertexAttribArray(lightingNormalAttibLocation);\r\n    // second, configure the light's VAO (VBO stays the same; the vertices are the same for the light object which is also a 3D cube)\r\n    let lightCubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(lightCubeVAO);\r\n    gl.vertexAttribPointer(lampPositionAttibLocation, 3, gl.FLOAT, false, 6 * 4, 0);\r\n    gl.enableVertexAttribArray(lampPositionAttibLocation);\r\n    _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(canvas);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    gl.useProgram(lightingProgram);\r\n    gl.uniform3fv(objectColorLocation, [1.0, 0.5, 0.31]);\r\n    gl.uniform3fv(lightColorLocation, [1.0, 1.0, 1.0]);\r\n    gl.uniform3fv(lightPosLocation, lightPos);\r\n    function getTime(time) {\r\n        let currentFrame = time;\r\n        deltaTime = (currentFrame - lastFrame) * 0.001;\r\n        lastFrame = currentFrame;\r\n        requestAnimationFrame(getTime);\r\n    }\r\n    drawScene();\r\n    requestAnimationFrame(getTime);\r\n    function drawScene() {\r\n        gl.clearColor(0.1, 0.1, 0.1, 1.0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        // be sure to activate shader when setting uniforms/drawing objects\r\n        gl.useProgram(lightingProgram);\r\n        let view = camera.GetViewMatrix();\r\n        view = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].inverse(view);\r\n        gl.uniformMatrix4fv(lightingViewLocation, false, view);\r\n        let glcanvas = gl.canvas;\r\n        let aspect = glcanvas.clientWidth / glcanvas.clientHeight;\r\n        let projection = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].perspective(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(camera.Zoom), aspect, 0.1, 100);\r\n        gl.uniformMatrix4fv(lightingProjectionLocation, false, projection);\r\n        let model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n        gl.uniformMatrix4fv(lightingModelLocation, false, model);\r\n        // render the cube\r\n        gl.bindVertexArray(cubeVAO);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n        // also draw the lamp object\r\n        gl.useProgram(lampProgram);\r\n        gl.uniformMatrix4fv(lampProjectionLocation, false, projection);\r\n        gl.uniformMatrix4fv(lampViewLocation, false, view);\r\n        model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(model, lightPos);\r\n        model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].scale(model, 0.2, 0.2, 0.2);\r\n        gl.uniformMatrix4fv(lampModelLocation, false, model);\r\n        gl.bindVertexArray(lightCubeVAO);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n    }\r\n    document.onkeydown = (event) => {\r\n        // return;\r\n        var e = event || window.event || arguments.callee.caller.arguments[0];\r\n        if (e && e.keyCode == 87) { // 按 W \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.FORWARD, deltaTime);\r\n        }\r\n        else if (e && e.keyCode == 83) { // 按 S \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.BACKWARD, deltaTime);\r\n        }\r\n        else if (e && e.keyCode == 65) { // A\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.LEFT, deltaTime);\r\n        }\r\n        else if (e && e.keyCode == 68) { // D\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.RIGHT, deltaTime);\r\n        }\r\n        drawScene();\r\n    };\r\n    canvas.onmousedown = (e) => {\r\n        // return;\r\n        lastX = e.clientX;\r\n        lastY = e.clientY;\r\n        fndown();\r\n    };\r\n    function fndown() {\r\n        canvas.onmousemove = (e) => {\r\n            let xpos = e.clientX;\r\n            let ypos = e.clientY;\r\n            if (firstMouse) {\r\n                lastX = xpos;\r\n                lastY = ypos;\r\n                firstMouse = false;\r\n            }\r\n            let xoffset = xpos - lastX;\r\n            let yoffset = lastY - ypos;\r\n            lastX = xpos;\r\n            lastY = ypos;\r\n            camera.ProcessMouseMovement(xoffset, yoffset);\r\n            drawScene();\r\n        };\r\n        canvas.onmouseup = (e) => {\r\n            canvas.onmousemove = null;\r\n            console.log(\"up\");\r\n        };\r\n    }\r\n    canvas.onwheel = (e) => {\r\n        let yoffset = e.deltaY;\r\n        camera.ProcessMouseSroll(yoffset);\r\n        drawScene();\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/2.lighting/02.basic_lighting_diffuse.ts?");

/***/ }),

/***/ "./src/2.lighting/03.basic_lighting_specular.ts":
/*!******************************************************!*\
  !*** ./src/2.lighting/03.basic_lighting_specular.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n/* harmony import */ var _resources_glm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/glm */ \"./src/resources/glm.ts\");\n/* harmony import */ var _resources_camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/camera */ \"./src/resources/camera.ts\");\n\r\n\r\n\r\nconst vsBasicLighting = `#version 300 es\r\nin vec3 aPos;\r\nin vec3 aNormal;\r\n\r\nout vec3 FragPos;\r\nout vec3 Normal;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    FragPos = vec3(model * vec4(aPos, 1.0));\r\n    Normal = mat3(transpose(inverse(model))) * aNormal;\r\n\r\n    gl_Position = projection * view * vec4(FragPos, 1.0);\r\n}`;\r\nconst fsBasicLighting = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nin vec3 Normal;\r\nin vec3 FragPos;\r\n\r\n\r\nuniform vec3 lightPos;\r\nuniform vec3 viewPos;\r\nuniform vec3 lightColor;\r\nuniform vec3 objectColor;\r\n\r\nvoid main() {\r\n    // ambient\r\n    float ambientStrengh = 0.1;\r\n    vec3 ambient = ambientStrengh * lightColor;\r\n\r\n    // diffuse\r\n    vec3 norm = normalize(Normal);\r\n    vec3 lightDir = normalize(lightPos - FragPos);\r\n    float diff = max(dot(norm, lightDir), 0.0);\r\n    vec3 diffuse = diff * lightColor;\r\n\r\n    //specular\r\n    float specularStrength = 0.5;\r\n    vec3 viewDir = normalize(viewPos - FragPos);\r\n    vec3 reflectDir = reflect(-lightDir, norm);\r\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\r\n    vec3 specular = specularStrength * spec * lightColor;\r\n\r\n    vec3 result = (ambient + diffuse + specular) * objectColor;\r\n    FragColor = vec4(result, 1.0);\r\n}`;\r\nconst vsLightCube = `#version 300 es\r\nin vec3 aPos;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    gl_Position = projection * view * model * vec4(aPos, 1.0);    \r\n}`;\r\nconst fsLightCube = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nvoid main(){\r\n    FragColor = vec4(1.0);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.querySelector('#c');\r\n    const gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let camera = new _resources_camera__WEBPACK_IMPORTED_MODULE_2__[\"default\"]([0, 0, 3]);\r\n    let lastX = gl.canvas.width / 2;\r\n    let lastY = gl.canvas.height / 2;\r\n    let firstMouse = true;\r\n    let deltaTime = 0;\r\n    let lastFrame = 0;\r\n    let lightPos = [1.2, 1, 2];\r\n    let lightingProgram = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createProgramFromStrings(gl, [vsBasicLighting, fsBasicLighting]);\r\n    let lightCubeProgram = _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createProgramFromStrings(gl, [vsLightCube, fsLightCube]);\r\n    let lightingPositionAttibLocation = gl.getAttribLocation(lightingProgram, 'aPos');\r\n    let lightingNormalAttibLocation = gl.getAttribLocation(lightingProgram, 'aNormal');\r\n    let lightPosLocation = gl.getUniformLocation(lightingProgram, 'lightPos');\r\n    let viewPosLocation = gl.getUniformLocation(lightingProgram, 'viewPos');\r\n    let lightColorLocation = gl.getUniformLocation(lightingProgram, 'lightColor');\r\n    let objectColorLocation = gl.getUniformLocation(lightingProgram, 'objectColor');\r\n    let lightingModelLocation = gl.getUniformLocation(lightingProgram, 'model');\r\n    let lightingViewLocation = gl.getUniformLocation(lightingProgram, 'view');\r\n    let lightingProjectionLocation = gl.getUniformLocation(lightingProgram, 'projection');\r\n    let lightCubePositionAttibLocation = gl.getAttribLocation(lightCubeProgram, 'aPos');\r\n    let lightCubeModelLocation = gl.getUniformLocation(lightCubeProgram, 'model');\r\n    let lightCubeViewLocation = gl.getUniformLocation(lightCubeProgram, 'view');\r\n    let lightCubeProjectionLocation = gl.getUniformLocation(lightCubeProgram, 'projection');\r\n    const vertices = [\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0,\r\n        0.5, -0.5, -0.5, 0.0, 0.0, -1.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 0.0, -1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, 0.5, 0.0, 0.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0,\r\n        -0.5, 0.5, 0.5, 0.0, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0,\r\n        -0.5, 0.5, -0.5, -1.0, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0,\r\n        -0.5, -0.5, 0.5, -1.0, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 0.0, 0.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0,\r\n        0.5, -0.5, -0.5, 0.0, -1.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, -1.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, 0.5, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0\r\n    ];\r\n    // first, configure the cube's VAO (and VBO)\r\n    let cubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(cubeVAO);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(lightingPositionAttibLocation, 3, gl.FLOAT, false, 6 * 4, 0);\r\n    gl.enableVertexAttribArray(lightingPositionAttibLocation);\r\n    gl.vertexAttribPointer(lightingNormalAttibLocation, 3, gl.FLOAT, false, 6 * 4, 3 * 4);\r\n    gl.enableVertexAttribArray(lightingNormalAttibLocation);\r\n    // second, configure the light's VAO (VBO stays the same; the vertices are the same for the light object which is also a 3D cube)\r\n    let lightCubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(lightCubeVAO);\r\n    gl.vertexAttribPointer(lightCubePositionAttibLocation, 3, gl.FLOAT, false, 6 * 4, 0);\r\n    gl.enableVertexAttribArray(lightCubePositionAttibLocation);\r\n    _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(canvas);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    gl.useProgram(lightingProgram);\r\n    gl.uniform3fv(objectColorLocation, [1.0, 0.5, 0.31]);\r\n    gl.uniform3fv(lightColorLocation, [1.0, 1.0, 1.0]);\r\n    gl.uniform3fv(lightPosLocation, lightPos);\r\n    gl.uniform3fv(viewPosLocation, camera.Position);\r\n    function getTime(time) {\r\n        let currentFrame = time;\r\n        deltaTime = (currentFrame - lastFrame) * 0.001;\r\n        lastFrame = currentFrame;\r\n        requestAnimationFrame(getTime);\r\n    }\r\n    drawScene();\r\n    requestAnimationFrame(getTime);\r\n    function drawScene() {\r\n        gl.clearColor(0.1, 0.1, 0.1, 1.0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        // be sure to activate shader when setting uniforms/drawing objects\r\n        gl.useProgram(lightingProgram);\r\n        gl.uniform3fv(viewPosLocation, camera.Position);\r\n        let glcanvas = gl.canvas;\r\n        let aspect = glcanvas.clientWidth / glcanvas.clientHeight;\r\n        let projection = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].perspective(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(camera.Zoom), aspect, 0.1, 100);\r\n        gl.uniformMatrix4fv(lightingProjectionLocation, false, projection);\r\n        let view = camera.GetViewMatrix();\r\n        view = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].inverse(view);\r\n        gl.uniformMatrix4fv(lightingViewLocation, false, view);\r\n        let model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n        gl.uniformMatrix4fv(lightingModelLocation, false, model);\r\n        // render the cube\r\n        gl.bindVertexArray(cubeVAO);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n        // also draw the lamp object\r\n        gl.useProgram(lightCubeProgram);\r\n        gl.uniformMatrix4fv(lightCubeProjectionLocation, false, projection);\r\n        gl.uniformMatrix4fv(lightCubeViewLocation, false, view);\r\n        model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(model, lightPos);\r\n        model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].scale(model, 0.2, 0.2, 0.2);\r\n        gl.uniformMatrix4fv(lightCubeModelLocation, false, model);\r\n        gl.bindVertexArray(lightCubeVAO);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n    }\r\n    document.onkeydown = (event) => {\r\n        var e = event || window.event || arguments.callee.caller.arguments[0];\r\n        if (e && e.keyCode == 87) { // 按 W \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.FORWARD, deltaTime);\r\n            // console.log('wwwww');\r\n        }\r\n        else if (e && e.keyCode == 83) { // 按 S \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.BACKWARD, deltaTime);\r\n            // console.log('sssss');\r\n        }\r\n        else if (e && e.keyCode == 65) { // A\r\n            // console.log('aaaaa');\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.LEFT, deltaTime);\r\n        }\r\n        else if (e && e.keyCode == 68) { // D\r\n            // console.log('ddddd');\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.RIGHT, deltaTime);\r\n        }\r\n        drawScene();\r\n    };\r\n    canvas.onmousedown = (e) => {\r\n        lastX = e.clientX;\r\n        lastY = e.clientY;\r\n        fndown();\r\n    };\r\n    function fndown() {\r\n        canvas.onmousemove = (e) => {\r\n            let xpos = e.clientX;\r\n            let ypos = e.clientY;\r\n            if (firstMouse) {\r\n                lastX = xpos;\r\n                lastY = ypos;\r\n                firstMouse = false;\r\n            }\r\n            let xoffset = xpos - lastX;\r\n            let yoffset = lastY - ypos;\r\n            lastX = xpos;\r\n            lastY = ypos;\r\n            camera.ProcessMouseMovement(xoffset, yoffset);\r\n            drawScene();\r\n        };\r\n        canvas.onmouseup = (e) => {\r\n            canvas.onmousemove = null;\r\n            console.log(\"up\");\r\n        };\r\n    }\r\n    canvas.onwheel = (e) => {\r\n        let yoffset = e.deltaY;\r\n        camera.ProcessMouseSroll(yoffset);\r\n        drawScene();\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/2.lighting/03.basic_lighting_specular.ts?");

/***/ }),

/***/ "./src/2.lighting/04.materials.ts":
/*!****************************************!*\
  !*** ./src/2.lighting/04.materials.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n/* harmony import */ var _resources_glm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/glm */ \"./src/resources/glm.ts\");\n/* harmony import */ var _resources_camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/camera */ \"./src/resources/camera.ts\");\n/* harmony import */ var _resources_Shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../resources/Shader */ \"./src/resources/Shader.ts\");\n/* harmony import */ var _resources_glMatrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../resources/glMatrix */ \"./src/resources/glMatrix/index.ts\");\n\r\n\r\n\r\n\r\n\r\nconst vsMaterials = `#version 300 es\r\nin vec3 aPos;\r\nin vec3 aNormal;\r\n\r\nout vec3 FragPos;\r\nout vec3 Normal;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    FragPos = vec3(model * vec4(aPos, 1.0));\r\n    Normal = mat3(transpose(inverse(model))) * aNormal;\r\n\r\n    gl_Position = projection * view * vec4(FragPos, 1.0);\r\n}`;\r\nconst fsMaterials = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nstruct Material{\r\n    vec3 ambient;\r\n    vec3 diffuse;\r\n    vec3 specular;\r\n    float shininess;\r\n};\r\n\r\nstruct Light{\r\n    vec3 position;\r\n    \r\n    vec3 ambient;\r\n    vec3 diffuse;\r\n    vec3 specular;\r\n};\r\n\r\nin vec3 Normal;\r\nin vec3 FragPos;\r\n\r\nuniform vec3 viewPos;\r\nuniform Material material;\r\nuniform Light light;\r\n\r\nvoid main() {\r\n    // ambient\r\n    vec3 ambient = light.ambient * material.ambient;\r\n\r\n    // diffuse\r\n    vec3 norm = normalize(Normal);\r\n    vec3 lightDir = normalize(light.position - FragPos);\r\n    float diff = max(dot(norm, lightDir), 0.0);\r\n    vec3 diffuse = light.diffuse * (diff * material.diffuse);\r\n\r\n    //specular\r\n    vec3 viewDir = normalize(viewPos - FragPos);\r\n    vec3 reflectDir = reflect(-lightDir, norm);\r\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\r\n    vec3 specular = light.specular * (spec * material.specular);\r\n\r\n    vec3 result = ambient + diffuse + specular;\r\n    FragColor = vec4(result, 1.0);\r\n}`;\r\nconst vsLightCube = `#version 300 es\r\nin vec3 aPos;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    gl_Position = projection * view * model * vec4(aPos, 1.0);    \r\n}`;\r\nconst fsLightCube = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nvoid main(){\r\n    FragColor = vec4(1.0);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.querySelector('#c');\r\n    const gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let camera = new _resources_camera__WEBPACK_IMPORTED_MODULE_2__[\"default\"]([0, 0, 3]);\r\n    let lastX = gl.canvas.width / 2;\r\n    let lastY = gl.canvas.height / 2;\r\n    let firstMouse = true;\r\n    let deltaTime = 0;\r\n    let lastFrame = 0;\r\n    let lightPos = [1.2, 1, 2];\r\n    let lightingShader = new _resources_Shader__WEBPACK_IMPORTED_MODULE_3__[\"default\"](gl, vsMaterials, fsMaterials);\r\n    let lightCubeShader = new _resources_Shader__WEBPACK_IMPORTED_MODULE_3__[\"default\"](gl, vsLightCube, fsLightCube);\r\n    let lightingPositionAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aPos');\r\n    let lightingNormalAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aNormal');\r\n    let lightCubePositionAttibLocation = gl.getAttribLocation(lightCubeShader.ID, 'aPos');\r\n    const vertices = [\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0,\r\n        0.5, -0.5, -0.5, 0.0, 0.0, -1.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 0.0, -1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, 0.5, 0.0, 0.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0,\r\n        -0.5, 0.5, 0.5, 0.0, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0,\r\n        -0.5, 0.5, -0.5, -1.0, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0,\r\n        -0.5, -0.5, 0.5, -1.0, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 0.0, 0.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0,\r\n        0.5, -0.5, -0.5, 0.0, -1.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, -1.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, 0.5, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0\r\n    ];\r\n    // first, configure the cube's VAO (and VBO)\r\n    let cubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(cubeVAO);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(lightingPositionAttibLocation, 3, gl.FLOAT, false, 6 * 4, 0);\r\n    gl.enableVertexAttribArray(lightingPositionAttibLocation);\r\n    gl.vertexAttribPointer(lightingNormalAttibLocation, 3, gl.FLOAT, false, 6 * 4, 3 * 4);\r\n    gl.enableVertexAttribArray(lightingNormalAttibLocation);\r\n    // second, configure the light's VAO (VBO stays the same; the vertices are the same for the light object which is also a 3D cube)\r\n    let lightCubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(lightCubeVAO);\r\n    gl.vertexAttribPointer(lightCubePositionAttibLocation, 3, gl.FLOAT, false, 6 * 4, 0);\r\n    gl.enableVertexAttribArray(lightCubePositionAttibLocation);\r\n    _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(canvas);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    // gl.useProgram(lightingShader);\r\n    lightingShader.use();\r\n    lightingShader.setVec3('material.ambient', 1.0, 0.5, 0.31);\r\n    lightingShader.setVec3('material.diffuse', 1.0, 0.5, 0.31);\r\n    lightingShader.setVec3('material.specular', 0.5, 0.5, 0.5);\r\n    lightingShader.setFloat('material.shininess', 32);\r\n    requestAnimationFrame(drawScene);\r\n    function drawScene(time) {\r\n        let currentFrame = time;\r\n        deltaTime = (currentFrame - lastFrame) * 0.001;\r\n        lastFrame = currentFrame;\r\n        gl.clearColor(0.1, 0.1, 0.1, 1.0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        // be sure to activate shader when setting uniforms/drawing objects\r\n        // gl.useProgram(lightingShader);\r\n        // gl.uniform3fv(viewPosLocation, camera.Position);\r\n        lightingShader.use();\r\n        lightingShader.setVec3('light.position', lightPos);\r\n        lightingShader.setVec3('viewPos', camera.Position);\r\n        let lightColor = [\r\n            Math.sin(time * 0.001 * 2),\r\n            Math.sin(time * 0.001 * 0.7),\r\n            Math.sin(time * 0.001 * 1.3)\r\n        ];\r\n        let diffuseColor = _resources_glMatrix__WEBPACK_IMPORTED_MODULE_4__.vec3.mul(lightColor, [0.5, 0.5, 0.5]);\r\n        let ambientColor = _resources_glMatrix__WEBPACK_IMPORTED_MODULE_4__.vec3.mul(diffuseColor, [0.2, 0.2, 0.2]);\r\n        lightingShader.setVec3('light.ambient', ambientColor);\r\n        lightingShader.setVec3('light.diffuse', diffuseColor);\r\n        lightingShader.setVec3('light.specular', 1, 1, 1);\r\n        let glcanvas = gl.canvas;\r\n        let aspect = glcanvas.clientWidth / glcanvas.clientHeight;\r\n        let projection = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].perspective(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(camera.Zoom), aspect, 0.1, 100);\r\n        lightingShader.setMat4('projection', projection);\r\n        let view = camera.GetViewMatrix();\r\n        view = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].inverse(view);\r\n        lightingShader.setMat4('view', view);\r\n        let model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n        lightingShader.setMat4('model', model);\r\n        // render the cube\r\n        gl.bindVertexArray(cubeVAO);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n        // also draw the lamp object\r\n        lightCubeShader.use();\r\n        lightCubeShader.setMat4('projection', projection);\r\n        lightCubeShader.setMat4('view', view);\r\n        model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(model, lightPos);\r\n        model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].scale(model, 0.2, 0.2, 0.2);\r\n        lightCubeShader.setMat4('model', model);\r\n        gl.bindVertexArray(lightCubeVAO);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n        requestAnimationFrame(drawScene);\r\n    }\r\n    document.onkeydown = (event) => {\r\n        var e = event || window.event || arguments.callee.caller.arguments[0];\r\n        if (e && e.keyCode == 87) { // 按 W \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.FORWARD, deltaTime);\r\n            // console.log('wwwww');\r\n        }\r\n        else if (e && e.keyCode == 83) { // 按 S \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.BACKWARD, deltaTime);\r\n            // console.log('sssss');\r\n        }\r\n        else if (e && e.keyCode == 65) { // A\r\n            // console.log('aaaaa');\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.LEFT, deltaTime);\r\n        }\r\n        else if (e && e.keyCode == 68) { // D\r\n            // console.log('ddddd');\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.RIGHT, deltaTime);\r\n        }\r\n    };\r\n    canvas.onmousedown = (e) => {\r\n        lastX = e.clientX;\r\n        lastY = e.clientY;\r\n        fndown();\r\n    };\r\n    function fndown() {\r\n        canvas.onmousemove = (e) => {\r\n            let xpos = e.clientX;\r\n            let ypos = e.clientY;\r\n            if (firstMouse) {\r\n                lastX = xpos;\r\n                lastY = ypos;\r\n                firstMouse = false;\r\n            }\r\n            let xoffset = xpos - lastX;\r\n            let yoffset = lastY - ypos;\r\n            lastX = xpos;\r\n            lastY = ypos;\r\n            camera.ProcessMouseMovement(xoffset, yoffset);\r\n        };\r\n        canvas.onmouseup = (e) => {\r\n            canvas.onmousemove = null;\r\n            console.log(\"up\");\r\n        };\r\n    }\r\n    canvas.onwheel = (e) => {\r\n        let yoffset = e.deltaY;\r\n        camera.ProcessMouseSroll(yoffset);\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/2.lighting/04.materials.ts?");

/***/ }),

/***/ "./src/2.lighting/05.lighting_maps_diffuse.ts":
/*!****************************************************!*\
  !*** ./src/2.lighting/05.lighting_maps_diffuse.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n/* harmony import */ var _resources_glm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/glm */ \"./src/resources/glm.ts\");\n/* harmony import */ var _resources_camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/camera */ \"./src/resources/camera.ts\");\n/* harmony import */ var _resources_Shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../resources/Shader */ \"./src/resources/Shader.ts\");\n\r\n\r\n\r\n\r\nconst vsMaterials = `#version 300 es\r\n\r\nin vec3 aPos;\r\nin vec3 aNormal;\r\nin vec2 aTexCoords;\r\n\r\nout vec3 FragPos;\r\nout vec3 Normal;\r\nout vec2 TexCoords;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    FragPos = vec3(model * vec4(aPos, 1.0));\r\n    Normal = mat3(transpose(inverse(model))) * aNormal;\r\n    TexCoords = aTexCoords;\r\n\r\n    gl_Position = projection * view * vec4(FragPos, 1.0);\r\n}`;\r\nconst fsMaterials = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nstruct Material{\r\n    sampler2D diffuse;\r\n    vec3 specular;\r\n    float shininess;\r\n};\r\n\r\nstruct Light{\r\n    vec3 position;\r\n    \r\n    vec3 ambient;\r\n    vec3 diffuse;\r\n    vec3 specular;\r\n};\r\n\r\nin vec3 Normal;\r\nin vec3 FragPos;\r\nin vec2 TexCoords;\r\n\r\nuniform vec3 viewPos;\r\nuniform Material material;\r\nuniform Light light;\r\n\r\nvoid main() {\r\n    // ambient\r\n    vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;\r\n\r\n    // diffuse\r\n    vec3 norm = normalize(Normal);\r\n    vec3 lightDir = normalize(light.position - FragPos);\r\n    float diff = max(dot(norm, lightDir), 0.0);\r\n    vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;\r\n\r\n    //specular\r\n    vec3 viewDir = normalize(viewPos - FragPos);\r\n    vec3 reflectDir = reflect(-lightDir, norm);\r\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\r\n    vec3 specular = light.specular * (spec * material.specular);\r\n\r\n    vec3 result = ambient + diffuse + specular;\r\n    FragColor = vec4(result, 1.0);\r\n}`;\r\nconst vsLightCube = `#version 300 es\r\nin vec3 aPos;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    gl_Position = projection * view * model * vec4(aPos, 1.0);    \r\n}`;\r\nconst fsLightCube = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nvoid main(){\r\n    FragColor = vec4(1.0);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.querySelector('#c');\r\n    const gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let camera = new _resources_camera__WEBPACK_IMPORTED_MODULE_2__[\"default\"]([0, 0, 3]);\r\n    let lastX = gl.canvas.width / 2;\r\n    let lastY = gl.canvas.height / 2;\r\n    let firstMouse = true;\r\n    let deltaTime = 0;\r\n    let lastFrame = 0;\r\n    let lightPos = [1.2, 1, 2];\r\n    let lightingShader = new _resources_Shader__WEBPACK_IMPORTED_MODULE_3__[\"default\"](gl, vsMaterials, fsMaterials);\r\n    let lightCubeShader = new _resources_Shader__WEBPACK_IMPORTED_MODULE_3__[\"default\"](gl, vsLightCube, fsLightCube);\r\n    let lightingPositionAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aPos');\r\n    let lightingNormalAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aNormal');\r\n    let lightingTexCoordsAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aTexCoords');\r\n    let lightCubePositionAttibLocation = gl.getAttribLocation(lightCubeShader.ID, 'aPos');\r\n    const vertices = [\r\n        // positions       // normals        // texture coords\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 0.0,\r\n        0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 1.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 1.0,\r\n        -0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, -0.5, -1.0, 0.0, 0.0, 1.0, 1.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, -1.0, 0.0, 0.0, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 0.0, 0.0, 1.0, 1.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0, 0.0, 0.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0, 1.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 1.0, 1.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 1.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 1.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 0.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.0, 1.0,\r\n        0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.0, 1.0\r\n    ];\r\n    // first, configure the cube's VAO (and VBO)\r\n    let cubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(cubeVAO);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(lightingPositionAttibLocation, 3, gl.FLOAT, false, 8 * 4, 0);\r\n    gl.enableVertexAttribArray(lightingPositionAttibLocation);\r\n    gl.vertexAttribPointer(lightingNormalAttibLocation, 3, gl.FLOAT, false, 8 * 4, 3 * 4);\r\n    gl.enableVertexAttribArray(lightingNormalAttibLocation);\r\n    gl.vertexAttribPointer(lightingTexCoordsAttibLocation, 2, gl.FLOAT, false, 8 * 4, 6 * 4);\r\n    gl.enableVertexAttribArray(lightingTexCoordsAttibLocation);\r\n    // second, configure the light's VAO (VBO stays the same; the vertices are the same for the light object which is also a 3D cube)\r\n    let lightCubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(lightCubeVAO);\r\n    gl.vertexAttribPointer(lightCubePositionAttibLocation, 3, gl.FLOAT, false, 8 * 4, 0);\r\n    gl.enableVertexAttribArray(lightCubePositionAttibLocation);\r\n    _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(canvas);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    // gl.useProgram(lightingShader);\r\n    lightingShader.use();\r\n    lightingShader.setInt('material.diffuse', 0);\r\n    lightingShader.setVec3('material.specular', 0.5, 0.5, 0.5);\r\n    lightingShader.setFloat('material.shininess', 64);\r\n    let imagePaths = [\"./resources/images/container2.png\"];\r\n    const loadImage = function (imageSrc) {\r\n        let promise = new Promise((resolve, reject) => {\r\n            const image = new Image();\r\n            image.onload = () => {\r\n                resolve(image);\r\n            };\r\n            image.onerror = () => {\r\n                reject();\r\n            };\r\n            image.src = imageSrc;\r\n        });\r\n        return promise;\r\n    };\r\n    Promise.all(imagePaths.map(i => loadImage(i))).then(images => {\r\n        render(images);\r\n    });\r\n    function render(images) {\r\n        let textures = loadTexture(images);\r\n        textures.forEach((texture, index) => {\r\n            gl.activeTexture(gl.TEXTURE0 + index);\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        });\r\n        requestAnimationFrame(drawScene);\r\n        function drawScene(time) {\r\n            let currentFrame = time;\r\n            deltaTime = (currentFrame - lastFrame) * 0.001;\r\n            lastFrame = currentFrame;\r\n            gl.clearColor(0.1, 0.1, 0.1, 1.0);\r\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n            // be sure to activate shader when setting uniforms/drawing objects\r\n            // gl.useProgram(lightingShader);\r\n            // gl.uniform3fv(viewPosLocation, camera.Position);\r\n            lightingShader.use();\r\n            lightingShader.setVec3('light.position', lightPos);\r\n            lightingShader.setVec3('viewPos', camera.Position);\r\n            lightingShader.setVec3('light.ambient', 0.2, 0.2, 0.2);\r\n            lightingShader.setVec3('light.diffuse', 0.5, 0.5, 0.5);\r\n            lightingShader.setVec3('light.specular', 1, 1, 1);\r\n            let glcanvas = gl.canvas;\r\n            let aspect = glcanvas.clientWidth / glcanvas.clientHeight;\r\n            let projection = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].perspective(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(camera.Zoom), aspect, 0.1, 100);\r\n            lightingShader.setMat4('projection', projection);\r\n            let view = camera.GetViewMatrix();\r\n            view = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].inverse(view);\r\n            lightingShader.setMat4('view', view);\r\n            let model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n            lightingShader.setMat4('model', model);\r\n            // render the cube\r\n            gl.bindVertexArray(cubeVAO);\r\n            gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            // also draw the lamp object\r\n            lightCubeShader.use();\r\n            lightCubeShader.setMat4('projection', projection);\r\n            lightCubeShader.setMat4('view', view);\r\n            model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(model, lightPos);\r\n            model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].scale(model, 0.2, 0.2, 0.2);\r\n            lightCubeShader.setMat4('model', model);\r\n            gl.bindVertexArray(lightCubeVAO);\r\n            gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            requestAnimationFrame(drawScene);\r\n        }\r\n    }\r\n    function loadTexture(images) {\r\n        let textures = [];\r\n        for (let i = 0; i < images.length; i++) {\r\n            let image = images[i];\r\n            let texture = gl.createTexture();\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n            textures.push(texture);\r\n        }\r\n        return textures;\r\n    }\r\n    document.onkeydown = (event) => {\r\n        var e = event || window.event || arguments.callee.caller.arguments[0];\r\n        if (e && e.keyCode == 87) { // 按 W \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.FORWARD, deltaTime);\r\n            // console.log('wwwww');\r\n        }\r\n        else if (e && e.keyCode == 83) { // 按 S \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.BACKWARD, deltaTime);\r\n            // console.log('sssss');\r\n        }\r\n        else if (e && e.keyCode == 65) { // A\r\n            // console.log('aaaaa');\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.LEFT, deltaTime);\r\n        }\r\n        else if (e && e.keyCode == 68) { // D\r\n            // console.log('ddddd');\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.RIGHT, deltaTime);\r\n        }\r\n    };\r\n    canvas.onmousedown = (e) => {\r\n        lastX = e.clientX;\r\n        lastY = e.clientY;\r\n        fndown();\r\n    };\r\n    function fndown() {\r\n        canvas.onmousemove = (e) => {\r\n            let xpos = e.clientX;\r\n            let ypos = e.clientY;\r\n            if (firstMouse) {\r\n                lastX = xpos;\r\n                lastY = ypos;\r\n                firstMouse = false;\r\n            }\r\n            let xoffset = xpos - lastX;\r\n            let yoffset = lastY - ypos;\r\n            lastX = xpos;\r\n            lastY = ypos;\r\n            camera.ProcessMouseMovement(xoffset, yoffset);\r\n        };\r\n        canvas.onmouseup = (e) => {\r\n            canvas.onmousemove = null;\r\n            console.log(\"up\");\r\n        };\r\n    }\r\n    canvas.onwheel = (e) => {\r\n        let yoffset = e.deltaY;\r\n        camera.ProcessMouseSroll(yoffset);\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/2.lighting/05.lighting_maps_diffuse.ts?");

/***/ }),

/***/ "./src/2.lighting/06.lighting_maps_specular.ts":
/*!*****************************************************!*\
  !*** ./src/2.lighting/06.lighting_maps_specular.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n/* harmony import */ var _resources_glm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/glm */ \"./src/resources/glm.ts\");\n/* harmony import */ var _resources_camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/camera */ \"./src/resources/camera.ts\");\n/* harmony import */ var _resources_Shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../resources/Shader */ \"./src/resources/Shader.ts\");\n\r\n\r\n\r\n\r\nconst vsMaterials = `#version 300 es\r\n\r\nin vec3 aPos;\r\nin vec3 aNormal;\r\nin vec2 aTexCoords;\r\n\r\nout vec3 FragPos;\r\nout vec3 Normal;\r\nout vec2 TexCoords;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    FragPos = vec3(model * vec4(aPos, 1.0));\r\n    Normal = mat3(transpose(inverse(model))) * aNormal;\r\n    TexCoords = aTexCoords;\r\n\r\n    gl_Position = projection * view * vec4(FragPos, 1.0);\r\n}`;\r\nconst fsMaterials = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nstruct Material{\r\n    sampler2D diffuse;\r\n    sampler2D specular;\r\n    float shininess;\r\n};\r\n\r\nstruct Light{\r\n    vec3 position;\r\n    \r\n    vec3 ambient;\r\n    vec3 diffuse;\r\n    vec3 specular;\r\n};\r\n\r\nin vec3 Normal;\r\nin vec3 FragPos;\r\nin vec2 TexCoords;\r\n\r\nuniform vec3 viewPos;\r\nuniform Material material;\r\nuniform Light light;\r\n\r\nvoid main() {\r\n    // ambient\r\n    vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;\r\n\r\n    // diffuse\r\n    vec3 norm = normalize(Normal);\r\n    vec3 lightDir = normalize(light.position - FragPos);\r\n    float diff = max(dot(norm, lightDir), 0.0);\r\n    vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;\r\n\r\n    //specular\r\n    vec3 viewDir = normalize(viewPos - FragPos);\r\n    vec3 reflectDir = reflect(-lightDir, norm);\r\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\r\n    vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb;\r\n\r\n    vec3 result = ambient + diffuse + specular;\r\n    FragColor = vec4(result, 1.0);\r\n}`;\r\nconst vsLightCube = `#version 300 es\r\nin vec3 aPos;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    gl_Position = projection * view * model * vec4(aPos, 1.0);    \r\n}`;\r\nconst fsLightCube = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nvoid main(){\r\n    FragColor = vec4(1.0);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.querySelector('#c');\r\n    const gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let camera = new _resources_camera__WEBPACK_IMPORTED_MODULE_2__[\"default\"]([0, 0, 3]);\r\n    let lastX = gl.canvas.width / 2;\r\n    let lastY = gl.canvas.height / 2;\r\n    let firstMouse = true;\r\n    let deltaTime = 0;\r\n    let lastFrame = 0;\r\n    let lightPos = [1.2, 1, 2];\r\n    let lightingShader = new _resources_Shader__WEBPACK_IMPORTED_MODULE_3__[\"default\"](gl, vsMaterials, fsMaterials);\r\n    let lightCubeShader = new _resources_Shader__WEBPACK_IMPORTED_MODULE_3__[\"default\"](gl, vsLightCube, fsLightCube);\r\n    let lightingPositionAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aPos');\r\n    let lightingNormalAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aNormal');\r\n    let lightingTexCoordsAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aTexCoords');\r\n    let lightCubePositionAttibLocation = gl.getAttribLocation(lightCubeShader.ID, 'aPos');\r\n    const vertices = [\r\n        // positions       // normals        // texture coords\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 0.0,\r\n        0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 1.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 1.0,\r\n        -0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, -0.5, -1.0, 0.0, 0.0, 1.0, 1.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, -1.0, 0.0, 0.0, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 0.0, 0.0, 1.0, 1.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0, 0.0, 0.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0, 1.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 1.0, 1.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 1.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 1.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 0.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.0, 1.0,\r\n        0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.0, 1.0\r\n    ];\r\n    // first, configure the cube's VAO (and VBO)\r\n    let cubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(cubeVAO);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(lightingPositionAttibLocation, 3, gl.FLOAT, false, 8 * 4, 0);\r\n    gl.enableVertexAttribArray(lightingPositionAttibLocation);\r\n    gl.vertexAttribPointer(lightingNormalAttibLocation, 3, gl.FLOAT, false, 8 * 4, 3 * 4);\r\n    gl.enableVertexAttribArray(lightingNormalAttibLocation);\r\n    gl.vertexAttribPointer(lightingTexCoordsAttibLocation, 2, gl.FLOAT, false, 8 * 4, 6 * 4);\r\n    gl.enableVertexAttribArray(lightingTexCoordsAttibLocation);\r\n    // second, configure the light's VAO (VBO stays the same; the vertices are the same for the light object which is also a 3D cube)\r\n    let lightCubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(lightCubeVAO);\r\n    gl.vertexAttribPointer(lightCubePositionAttibLocation, 3, gl.FLOAT, false, 8 * 4, 0);\r\n    gl.enableVertexAttribArray(lightCubePositionAttibLocation);\r\n    _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(canvas);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    // gl.useProgram(lightingShader);\r\n    lightingShader.use();\r\n    lightingShader.setInt('material.diffuse', 0);\r\n    lightingShader.setInt('material.specular', 1);\r\n    lightingShader.setVec3('material.specular', 0.5, 0.5, 0.5);\r\n    lightingShader.setFloat('material.shininess', 64);\r\n    let imagePaths = [\"./resources/images/container2.png\", \"./resources/images/container2_specular.png\"];\r\n    const loadImage = function (imageSrc) {\r\n        let promise = new Promise((resolve, reject) => {\r\n            const image = new Image();\r\n            image.onload = () => {\r\n                resolve(image);\r\n            };\r\n            image.onerror = () => {\r\n                reject();\r\n            };\r\n            image.src = imageSrc;\r\n        });\r\n        return promise;\r\n    };\r\n    Promise.all(imagePaths.map(i => loadImage(i))).then(images => {\r\n        render(images);\r\n    });\r\n    function render(images) {\r\n        let textures = loadTexture(images);\r\n        textures.forEach((texture, index) => {\r\n            gl.activeTexture(gl.TEXTURE0 + index);\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        });\r\n        requestAnimationFrame(drawScene);\r\n        function drawScene(time) {\r\n            let currentFrame = time;\r\n            deltaTime = (currentFrame - lastFrame) * 0.001;\r\n            lastFrame = currentFrame;\r\n            gl.clearColor(0.1, 0.1, 0.1, 1.0);\r\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n            // be sure to activate shader when setting uniforms/drawing objects\r\n            // gl.useProgram(lightingShader);\r\n            // gl.uniform3fv(viewPosLocation, camera.Position);\r\n            lightingShader.use();\r\n            lightingShader.setVec3('light.position', lightPos);\r\n            lightingShader.setVec3('viewPos', camera.Position);\r\n            lightingShader.setVec3('light.ambient', 0.2, 0.2, 0.2);\r\n            lightingShader.setVec3('light.diffuse', 0.5, 0.5, 0.5);\r\n            lightingShader.setVec3('light.specular', 1, 1, 1);\r\n            let glcanvas = gl.canvas;\r\n            let aspect = glcanvas.clientWidth / glcanvas.clientHeight;\r\n            let projection = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].perspective(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(camera.Zoom), aspect, 0.1, 100);\r\n            lightingShader.setMat4('projection', projection);\r\n            let view = camera.GetViewMatrix();\r\n            view = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].inverse(view);\r\n            lightingShader.setMat4('view', view);\r\n            let model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n            lightingShader.setMat4('model', model);\r\n            // render the cube\r\n            gl.bindVertexArray(cubeVAO);\r\n            gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            // also draw the lamp object\r\n            lightCubeShader.use();\r\n            lightCubeShader.setMat4('projection', projection);\r\n            lightCubeShader.setMat4('view', view);\r\n            model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(model, lightPos);\r\n            model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].scale(model, 0.2, 0.2, 0.2);\r\n            lightCubeShader.setMat4('model', model);\r\n            gl.bindVertexArray(lightCubeVAO);\r\n            gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            requestAnimationFrame(drawScene);\r\n        }\r\n    }\r\n    function loadTexture(images) {\r\n        let textures = [];\r\n        for (let i = 0; i < images.length; i++) {\r\n            let image = images[i];\r\n            let texture = gl.createTexture();\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n            textures.push(texture);\r\n        }\r\n        return textures;\r\n    }\r\n    document.onkeydown = (event) => {\r\n        var e = event || window.event || arguments.callee.caller.arguments[0];\r\n        if (e && e.keyCode == 87) { // 按 W \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.FORWARD, deltaTime);\r\n            // console.log('wwwww');\r\n        }\r\n        else if (e && e.keyCode == 83) { // 按 S \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.BACKWARD, deltaTime);\r\n            // console.log('sssss');\r\n        }\r\n        else if (e && e.keyCode == 65) { // A\r\n            // console.log('aaaaa');\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.LEFT, deltaTime);\r\n        }\r\n        else if (e && e.keyCode == 68) { // D\r\n            // console.log('ddddd');\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.RIGHT, deltaTime);\r\n        }\r\n    };\r\n    canvas.onmousedown = (e) => {\r\n        lastX = e.clientX;\r\n        lastY = e.clientY;\r\n        fndown();\r\n    };\r\n    function fndown() {\r\n        canvas.onmousemove = (e) => {\r\n            let xpos = e.clientX;\r\n            let ypos = e.clientY;\r\n            if (firstMouse) {\r\n                lastX = xpos;\r\n                lastY = ypos;\r\n                firstMouse = false;\r\n            }\r\n            let xoffset = xpos - lastX;\r\n            let yoffset = lastY - ypos;\r\n            lastX = xpos;\r\n            lastY = ypos;\r\n            camera.ProcessMouseMovement(xoffset, yoffset);\r\n        };\r\n        canvas.onmouseup = (e) => {\r\n            canvas.onmousemove = null;\r\n            console.log(\"up\");\r\n        };\r\n    }\r\n    canvas.onwheel = (e) => {\r\n        let yoffset = e.deltaY;\r\n        camera.ProcessMouseSroll(yoffset);\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/2.lighting/06.lighting_maps_specular.ts?");

/***/ }),

/***/ "./src/2.lighting/07.light_casters_directional.ts":
/*!********************************************************!*\
  !*** ./src/2.lighting/07.light_casters_directional.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n/* harmony import */ var _resources_glm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/glm */ \"./src/resources/glm.ts\");\n/* harmony import */ var _resources_camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/camera */ \"./src/resources/camera.ts\");\n/* harmony import */ var _resources_Shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../resources/Shader */ \"./src/resources/Shader.ts\");\n\r\n\r\n\r\n\r\nconst vsMaterials = `#version 300 es\r\n\r\nin vec3 aPos;\r\nin vec3 aNormal;\r\nin vec2 aTexCoords;\r\n\r\nout vec3 FragPos;\r\nout vec3 Normal;\r\nout vec2 TexCoords;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    FragPos = vec3(model * vec4(aPos, 1.0));\r\n    Normal = mat3(transpose(inverse(model))) * aNormal;\r\n    TexCoords = aTexCoords;\r\n\r\n    gl_Position = projection * view * vec4(FragPos, 1.0);\r\n}`;\r\nconst fsMaterials = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nstruct Material{\r\n    sampler2D diffuse;\r\n    sampler2D specular;\r\n    float shininess;\r\n};\r\n\r\nstruct Light{\r\n    vec3 direction;\r\n    \r\n    vec3 ambient;\r\n    vec3 diffuse;\r\n    vec3 specular;\r\n};\r\n\r\nin vec3 Normal;\r\nin vec3 FragPos;\r\nin vec2 TexCoords;\r\n\r\nuniform vec3 viewPos;\r\nuniform Material material;\r\nuniform Light light;\r\n\r\nvoid main() {\r\n    // ambient\r\n    vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;\r\n\r\n    // diffuse\r\n    vec3 norm = normalize(Normal);\r\n    // vec3 lightDir = normalize(light.position - FragPos);\r\n    vec3 lightDir = normalize(-light.direction);\r\n    float diff = max(dot(norm, lightDir), 0.0);\r\n    vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;\r\n\r\n    //specular\r\n    vec3 viewDir = normalize(viewPos - FragPos);\r\n    vec3 reflectDir = reflect(-lightDir, norm);\r\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\r\n    vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb;\r\n\r\n    vec3 result = ambient + diffuse + specular;\r\n    FragColor = vec4(result, 1.0);\r\n}`;\r\nconst vsLightCube = `#version 300 es\r\nin vec3 aPos;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    gl_Position = projection * view * model * vec4(aPos, 1.0);    \r\n}`;\r\nconst fsLightCube = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nvoid main(){\r\n    FragColor = vec4(1.0);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.querySelector('#c');\r\n    const gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let camera = new _resources_camera__WEBPACK_IMPORTED_MODULE_2__[\"default\"]([0, 0, 3]);\r\n    let lastX = gl.canvas.width / 2;\r\n    let lastY = gl.canvas.height / 2;\r\n    let firstMouse = true;\r\n    let deltaTime = 0;\r\n    let lastFrame = 0;\r\n    // let lightPos = [1.2, 1, 2];\r\n    let lightingShader = new _resources_Shader__WEBPACK_IMPORTED_MODULE_3__[\"default\"](gl, vsMaterials, fsMaterials);\r\n    let lightCubeShader = new _resources_Shader__WEBPACK_IMPORTED_MODULE_3__[\"default\"](gl, vsLightCube, fsLightCube);\r\n    let lightingPositionAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aPos');\r\n    let lightingNormalAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aNormal');\r\n    let lightingTexCoordsAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aTexCoords');\r\n    let lightCubePositionAttibLocation = gl.getAttribLocation(lightCubeShader.ID, 'aPos');\r\n    const vertices = [\r\n        // positions       // normals        // texture coords\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 0.0,\r\n        0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 1.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 1.0,\r\n        -0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, -0.5, -1.0, 0.0, 0.0, 1.0, 1.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, -1.0, 0.0, 0.0, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 0.0, 0.0, 1.0, 1.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0, 0.0, 0.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0, 1.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 1.0, 1.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 1.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 1.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 0.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.0, 1.0,\r\n        0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.0, 1.0\r\n    ];\r\n    const cubePositions = [\r\n        [0.0, 0.0, 0.0],\r\n        [2.0, 5.0, -15.0],\r\n        [-1.5, -2.2, -2.5],\r\n        [-3.8, -2.0, -12.3],\r\n        [2.4, -0.4, -3.5],\r\n        [-1.7, 3.0, -7.5],\r\n        [1.3, -2.0, -2.5],\r\n        [1.5, 2.0, -2.5],\r\n        [1.5, 0.2, -1.5],\r\n        [-1.3, 1.0, -1.5]\r\n    ];\r\n    // first, configure the cube's VAO (and VBO)\r\n    let cubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(cubeVAO);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(lightingPositionAttibLocation, 3, gl.FLOAT, false, 8 * 4, 0);\r\n    gl.enableVertexAttribArray(lightingPositionAttibLocation);\r\n    gl.vertexAttribPointer(lightingNormalAttibLocation, 3, gl.FLOAT, false, 8 * 4, 3 * 4);\r\n    gl.enableVertexAttribArray(lightingNormalAttibLocation);\r\n    gl.vertexAttribPointer(lightingTexCoordsAttibLocation, 2, gl.FLOAT, false, 8 * 4, 6 * 4);\r\n    gl.enableVertexAttribArray(lightingTexCoordsAttibLocation);\r\n    // second, configure the light's VAO (VBO stays the same; the vertices are the same for the light object which is also a 3D cube)\r\n    let lightCubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(lightCubeVAO);\r\n    gl.vertexAttribPointer(lightCubePositionAttibLocation, 3, gl.FLOAT, false, 8 * 4, 0);\r\n    gl.enableVertexAttribArray(lightCubePositionAttibLocation);\r\n    _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(canvas);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    // gl.useProgram(lightingShader);\r\n    lightingShader.use();\r\n    lightingShader.setInt('material.diffuse', 0);\r\n    lightingShader.setInt('material.specular', 1);\r\n    lightingShader.setFloat('material.shininess', 32);\r\n    let imagePaths = [\"./resources/images/container2.png\", \"./resources/images/container2_specular.png\"];\r\n    const loadImage = function (imageSrc) {\r\n        let promise = new Promise((resolve, reject) => {\r\n            const image = new Image();\r\n            image.onload = () => {\r\n                resolve(image);\r\n            };\r\n            image.onerror = () => {\r\n                reject();\r\n            };\r\n            image.src = imageSrc;\r\n        });\r\n        return promise;\r\n    };\r\n    Promise.all(imagePaths.map(i => loadImage(i))).then(images => {\r\n        render(images);\r\n    });\r\n    function render(images) {\r\n        let textures = loadTexture(images);\r\n        textures.forEach((texture, index) => {\r\n            gl.activeTexture(gl.TEXTURE0 + index);\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        });\r\n        requestAnimationFrame(drawScene);\r\n        function drawScene(time) {\r\n            let currentFrame = time;\r\n            deltaTime = (currentFrame - lastFrame) * 0.001;\r\n            lastFrame = currentFrame;\r\n            gl.clearColor(0.1, 0.1, 0.1, 1.0);\r\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n            lightingShader.use();\r\n            lightingShader.setVec3('light.direction', [-0.2, -1, -0.3]);\r\n            lightingShader.setVec3('viewPos', camera.Position);\r\n            lightingShader.setVec3('light.ambient', 0.2, 0.2, 0.2);\r\n            lightingShader.setVec3('light.diffuse', 0.5, 0.5, 0.5);\r\n            lightingShader.setVec3('light.specular', 1, 1, 1);\r\n            let glcanvas = gl.canvas;\r\n            let aspect = glcanvas.clientWidth / glcanvas.clientHeight;\r\n            let projection = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].perspective(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(camera.Zoom), aspect, 0.1, 100);\r\n            lightingShader.setMat4('projection', projection);\r\n            let view = camera.GetViewMatrix();\r\n            view = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].inverse(view);\r\n            lightingShader.setMat4('view', view);\r\n            let model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n            lightingShader.setMat4('model', model);\r\n            // render the cube\r\n            gl.bindVertexArray(cubeVAO);\r\n            // gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            for (let i = 0; i < cubePositions.length; i++) {\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(model, cubePositions[i]);\r\n                let angle = 20 * i;\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].axisRotate(model, [1, 0.3, 0.5], angle);\r\n                lightingShader.setMat4(\"model\", model);\r\n                gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            }\r\n            // also draw the lamp object\r\n            // lightCubeShader.use();\r\n            // lightCubeShader.setMat4('projection', projection);\r\n            // lightCubeShader.setMat4('view', view);\r\n            // model = glm.translate(model, lightPos);\r\n            // model = glm.scale(model, 0.2, 0.2, 0.2);\r\n            // lightCubeShader.setMat4('model', model);\r\n            // gl.bindVertexArray(lightCubeVAO);\r\n            // gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            requestAnimationFrame(drawScene);\r\n        }\r\n    }\r\n    function loadTexture(images) {\r\n        let textures = [];\r\n        for (let i = 0; i < images.length; i++) {\r\n            let image = images[i];\r\n            let texture = gl.createTexture();\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n            textures.push(texture);\r\n        }\r\n        return textures;\r\n    }\r\n    document.onkeydown = (event) => {\r\n        var e = event || window.event || arguments.callee.caller.arguments[0];\r\n        if (e && e.keyCode == 87) { // 按 W \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.FORWARD, deltaTime);\r\n            // console.log('wwwww');\r\n        }\r\n        else if (e && e.keyCode == 83) { // 按 S \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.BACKWARD, deltaTime);\r\n            // console.log('sssss');\r\n        }\r\n        else if (e && e.keyCode == 65) { // A\r\n            // console.log('aaaaa');\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.LEFT, deltaTime);\r\n        }\r\n        else if (e && e.keyCode == 68) { // D\r\n            // console.log('ddddd');\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.RIGHT, deltaTime);\r\n        }\r\n    };\r\n    canvas.onmousedown = (e) => {\r\n        lastX = e.clientX;\r\n        lastY = e.clientY;\r\n        fndown();\r\n    };\r\n    function fndown() {\r\n        canvas.onmousemove = (e) => {\r\n            let xpos = e.clientX;\r\n            let ypos = e.clientY;\r\n            if (firstMouse) {\r\n                lastX = xpos;\r\n                lastY = ypos;\r\n                firstMouse = false;\r\n            }\r\n            let xoffset = xpos - lastX;\r\n            let yoffset = lastY - ypos;\r\n            lastX = xpos;\r\n            lastY = ypos;\r\n            camera.ProcessMouseMovement(xoffset, yoffset);\r\n        };\r\n        canvas.onmouseup = (e) => {\r\n            canvas.onmousemove = null;\r\n            console.log(\"up\");\r\n        };\r\n    }\r\n    canvas.onwheel = (e) => {\r\n        let yoffset = e.deltaY;\r\n        camera.ProcessMouseSroll(yoffset);\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/2.lighting/07.light_casters_directional.ts?");

/***/ }),

/***/ "./src/2.lighting/08.light_casters_point.ts":
/*!**************************************************!*\
  !*** ./src/2.lighting/08.light_casters_point.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n/* harmony import */ var _resources_glm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/glm */ \"./src/resources/glm.ts\");\n/* harmony import */ var _resources_camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/camera */ \"./src/resources/camera.ts\");\n/* harmony import */ var _resources_Shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../resources/Shader */ \"./src/resources/Shader.ts\");\n\r\n\r\n\r\n\r\nconst vsLightCasters = `#version 300 es\r\n\r\nin vec3 aPos;\r\nin vec3 aNormal;\r\nin vec2 aTexCoords;\r\n\r\nout vec3 FragPos;\r\nout vec3 Normal;\r\nout vec2 TexCoords;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    FragPos = vec3(model * vec4(aPos, 1.0));\r\n    Normal = mat3(transpose(inverse(model))) * aNormal;\r\n    TexCoords = aTexCoords;\r\n\r\n    gl_Position = projection * view * vec4(FragPos, 1.0);\r\n}`;\r\nconst fsLightCasters = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nstruct Material{\r\n    sampler2D diffuse;\r\n    sampler2D specular;\r\n    float shininess;\r\n};\r\n\r\nstruct Light{\r\n    vec3 position;\r\n    \r\n    vec3 ambient;\r\n    vec3 diffuse;\r\n    vec3 specular;\r\n\r\n    float constant;\r\n    float linear;\r\n    float quadratic;\r\n};\r\n\r\nin vec3 Normal;\r\nin vec3 FragPos;\r\nin vec2 TexCoords;\r\n\r\nuniform vec3 viewPos;\r\nuniform Material material;\r\nuniform Light light;\r\n\r\nvoid main() {\r\n    // ambient\r\n    vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;\r\n\r\n    // diffuse\r\n    vec3 norm = normalize(Normal);\r\n    vec3 lightDir = normalize(light.position - FragPos);\r\n    // vec3 lightDir = normalize(-light.direction);\r\n    float diff = max(dot(norm, lightDir), 0.0);\r\n    vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;\r\n\r\n    //specular\r\n    vec3 viewDir = normalize(viewPos - FragPos);\r\n    vec3 reflectDir = reflect(-lightDir, norm);\r\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\r\n    vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb;\r\n\r\n    // attenuation\r\n    float distance = length(light.position - FragPos);\r\n    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));\r\n\r\n    ambient *= attenuation;\r\n    diffuse *= attenuation;\r\n    specular *= attenuation;\r\n\r\n    vec3 result = ambient + diffuse + specular;\r\n    FragColor = vec4(result, 1.0);\r\n}`;\r\nconst vsLightCube = `#version 300 es\r\nin vec3 aPos;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    gl_Position = projection * view * model * vec4(aPos, 1.0);    \r\n}`;\r\nconst fsLightCube = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nvoid main(){\r\n    FragColor = vec4(1.0);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.querySelector('#c');\r\n    const gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let camera = new _resources_camera__WEBPACK_IMPORTED_MODULE_2__[\"default\"]([0, 0, 3]);\r\n    let lastX = gl.canvas.width / 2;\r\n    let lastY = gl.canvas.height / 2;\r\n    let firstMouse = true;\r\n    let deltaTime = 0;\r\n    let lastFrame = 0;\r\n    let lightPos = [1.2, 1, 2];\r\n    let lightingShader = new _resources_Shader__WEBPACK_IMPORTED_MODULE_3__[\"default\"](gl, vsLightCasters, fsLightCasters);\r\n    let lightCubeShader = new _resources_Shader__WEBPACK_IMPORTED_MODULE_3__[\"default\"](gl, vsLightCube, fsLightCube);\r\n    let lightingPositionAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aPos');\r\n    let lightingNormalAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aNormal');\r\n    let lightingTexCoordsAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aTexCoords');\r\n    let lightCubePositionAttibLocation = gl.getAttribLocation(lightCubeShader.ID, 'aPos');\r\n    const vertices = [\r\n        // positions       // normals        // texture coords\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 0.0,\r\n        0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 1.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 1.0,\r\n        -0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, -0.5, -1.0, 0.0, 0.0, 1.0, 1.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, -1.0, 0.0, 0.0, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 0.0, 0.0, 1.0, 1.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0, 0.0, 0.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0, 1.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 1.0, 1.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 1.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 1.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 0.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.0, 1.0,\r\n        0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.0, 1.0\r\n    ];\r\n    const cubePositions = [\r\n        [0.0, 0.0, 0.0],\r\n        [2.0, 5.0, -15.0],\r\n        [-1.5, -2.2, -2.5],\r\n        [-3.8, -2.0, -12.3],\r\n        [2.4, -0.4, -3.5],\r\n        [-1.7, 3.0, -7.5],\r\n        [1.3, -2.0, -2.5],\r\n        [1.5, 2.0, -2.5],\r\n        [1.5, 0.2, -1.5],\r\n        [-1.3, 1.0, -1.5]\r\n    ];\r\n    // first, configure the cube's VAO (and VBO)\r\n    let cubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(cubeVAO);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(lightingPositionAttibLocation, 3, gl.FLOAT, false, 8 * 4, 0);\r\n    gl.enableVertexAttribArray(lightingPositionAttibLocation);\r\n    gl.vertexAttribPointer(lightingNormalAttibLocation, 3, gl.FLOAT, false, 8 * 4, 3 * 4);\r\n    gl.enableVertexAttribArray(lightingNormalAttibLocation);\r\n    gl.vertexAttribPointer(lightingTexCoordsAttibLocation, 2, gl.FLOAT, false, 8 * 4, 6 * 4);\r\n    gl.enableVertexAttribArray(lightingTexCoordsAttibLocation);\r\n    // second, configure the light's VAO (VBO stays the same; the vertices are the same for the light object which is also a 3D cube)\r\n    let lightCubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(lightCubeVAO);\r\n    gl.vertexAttribPointer(lightCubePositionAttibLocation, 3, gl.FLOAT, false, 8 * 4, 0);\r\n    gl.enableVertexAttribArray(lightCubePositionAttibLocation);\r\n    _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(canvas);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    // gl.useProgram(lightingShader);\r\n    lightingShader.use();\r\n    lightingShader.setInt('material.diffuse', 0);\r\n    lightingShader.setInt('material.specular', 1);\r\n    lightingShader.setFloat('material.shininess', 32);\r\n    let imagePaths = [\"./resources/images/container2.png\", \"./resources/images/container2_specular.png\"];\r\n    const loadImage = function (imageSrc) {\r\n        let promise = new Promise((resolve, reject) => {\r\n            const image = new Image();\r\n            image.onload = () => {\r\n                resolve(image);\r\n            };\r\n            image.onerror = () => {\r\n                reject();\r\n            };\r\n            image.src = imageSrc;\r\n        });\r\n        return promise;\r\n    };\r\n    Promise.all(imagePaths.map(i => loadImage(i))).then(images => {\r\n        render(images);\r\n    });\r\n    function render(images) {\r\n        let textures = loadTexture(images);\r\n        textures.forEach((texture, index) => {\r\n            gl.activeTexture(gl.TEXTURE0 + index);\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        });\r\n        requestAnimationFrame(drawScene);\r\n        function drawScene(time) {\r\n            let currentFrame = time;\r\n            deltaTime = (currentFrame - lastFrame) * 0.001;\r\n            lastFrame = currentFrame;\r\n            gl.clearColor(0.1, 0.1, 0.1, 1.0);\r\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n            lightingShader.use();\r\n            lightingShader.setVec3('light.position', lightPos);\r\n            lightingShader.setVec3('viewPos', camera.Position);\r\n            lightingShader.setVec3('light.ambient', 0.2, 0.2, 0.2);\r\n            lightingShader.setVec3('light.diffuse', 0.5, 0.5, 0.5);\r\n            lightingShader.setVec3('light.specular', 1, 1, 1);\r\n            lightingShader.setFloat('light.constant', 1);\r\n            lightingShader.setFloat('light.linear', 0.09);\r\n            lightingShader.setFloat('light.quadratic', 0.032);\r\n            let glcanvas = gl.canvas;\r\n            let aspect = glcanvas.clientWidth / glcanvas.clientHeight;\r\n            let projection = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].perspective(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(camera.Zoom), aspect, 0.1, 100);\r\n            lightingShader.setMat4('projection', projection);\r\n            let view = camera.GetViewMatrix();\r\n            view = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].inverse(view);\r\n            lightingShader.setMat4('view', view);\r\n            let model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n            lightingShader.setMat4('model', model);\r\n            // render the cube\r\n            gl.bindVertexArray(cubeVAO);\r\n            // gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            for (let i = 0; i < cubePositions.length; i++) {\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(model, cubePositions[i]);\r\n                let angle = 20 * i;\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].axisRotate(model, [1, 0.3, 0.5], angle);\r\n                lightingShader.setMat4(\"model\", model);\r\n                gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            }\r\n            // also draw the lamp object\r\n            lightCubeShader.use();\r\n            lightCubeShader.setMat4('projection', projection);\r\n            lightCubeShader.setMat4('view', view);\r\n            model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(model, lightPos);\r\n            model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].scale(model, 0.2, 0.2, 0.2);\r\n            lightCubeShader.setMat4('model', model);\r\n            gl.bindVertexArray(lightCubeVAO);\r\n            gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            requestAnimationFrame(drawScene);\r\n        }\r\n    }\r\n    function loadTexture(images) {\r\n        let textures = [];\r\n        for (let i = 0; i < images.length; i++) {\r\n            let image = images[i];\r\n            let texture = gl.createTexture();\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n            textures.push(texture);\r\n        }\r\n        return textures;\r\n    }\r\n    document.onkeydown = (event) => {\r\n        var e = event || window.event || arguments.callee.caller.arguments[0];\r\n        if (e && e.keyCode == 87) { // 按 W \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.FORWARD, deltaTime);\r\n            // console.log('wwwww');\r\n        }\r\n        else if (e && e.keyCode == 83) { // 按 S \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.BACKWARD, deltaTime);\r\n            // console.log('sssss');\r\n        }\r\n        else if (e && e.keyCode == 65) { // A\r\n            // console.log('aaaaa');\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.LEFT, deltaTime);\r\n        }\r\n        else if (e && e.keyCode == 68) { // D\r\n            // console.log('ddddd');\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.RIGHT, deltaTime);\r\n        }\r\n    };\r\n    canvas.onmousedown = (e) => {\r\n        lastX = e.clientX;\r\n        lastY = e.clientY;\r\n        fndown();\r\n    };\r\n    function fndown() {\r\n        canvas.onmousemove = (e) => {\r\n            let xpos = e.clientX;\r\n            let ypos = e.clientY;\r\n            if (firstMouse) {\r\n                lastX = xpos;\r\n                lastY = ypos;\r\n                firstMouse = false;\r\n            }\r\n            let xoffset = xpos - lastX;\r\n            let yoffset = lastY - ypos;\r\n            lastX = xpos;\r\n            lastY = ypos;\r\n            camera.ProcessMouseMovement(xoffset, yoffset);\r\n        };\r\n        canvas.onmouseup = (e) => {\r\n            canvas.onmousemove = null;\r\n            console.log(\"up\");\r\n        };\r\n    }\r\n    canvas.onwheel = (e) => {\r\n        let yoffset = e.deltaY;\r\n        camera.ProcessMouseSroll(yoffset);\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/2.lighting/08.light_casters_point.ts?");

/***/ }),

/***/ "./src/2.lighting/09.light_casters_spot.ts":
/*!*************************************************!*\
  !*** ./src/2.lighting/09.light_casters_spot.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n/* harmony import */ var _resources_glm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/glm */ \"./src/resources/glm.ts\");\n/* harmony import */ var _resources_camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/camera */ \"./src/resources/camera.ts\");\n/* harmony import */ var _resources_Shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../resources/Shader */ \"./src/resources/Shader.ts\");\n\r\n\r\n\r\n\r\nconst vsLightCasters = `#version 300 es\r\n\r\nin vec3 aPos;\r\nin vec3 aNormal;\r\nin vec2 aTexCoords;\r\n\r\nout vec3 FragPos;\r\nout vec3 Normal;\r\nout vec2 TexCoords;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    FragPos = vec3(model * vec4(aPos, 1.0));\r\n    Normal = mat3(transpose(inverse(model))) * aNormal;\r\n    TexCoords = aTexCoords;\r\n\r\n    gl_Position = projection * view * vec4(FragPos, 1.0);\r\n}`;\r\nconst fsLightCasters = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nstruct Material{\r\n    sampler2D diffuse;\r\n    sampler2D specular;\r\n    float shininess;\r\n};\r\n\r\nstruct Light{\r\n    vec3 position;\r\n    vec3 direction;\r\n    float cutOff;\r\n    float outerCutOff;\r\n    \r\n    vec3 ambient;\r\n    vec3 diffuse;\r\n    vec3 specular;\r\n\r\n    float constant;\r\n    float linear;\r\n    float quadratic;\r\n};\r\n\r\nin vec3 Normal;\r\nin vec3 FragPos;\r\nin vec2 TexCoords;\r\n\r\nuniform vec3 viewPos;\r\nuniform Material material;\r\nuniform Light light;\r\n\r\nvoid main() {\r\n\r\n    vec3 lightDir = normalize(light.position - FragPos);\r\n\r\n    float theta = dot(lightDir, normalize(-light.direction));\r\n\r\n    if(theta > light.cutOff){\r\n        // ambient\r\n        vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;\r\n\r\n        // diffuse\r\n        vec3 norm = normalize(Normal);\r\n        float diff = max(dot(norm, lightDir), 0.0);\r\n        vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;\r\n\r\n        //specular\r\n        vec3 viewDir = normalize(viewPos - FragPos);\r\n        vec3 reflectDir = reflect(-lightDir, norm);\r\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\r\n        vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb;\r\n\r\n        // attenuation\r\n        float distance = length(light.position - FragPos);\r\n        float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));\r\n\r\n        // ambient *= attenuation;\r\n        diffuse *= attenuation;\r\n        specular *= attenuation;\r\n\r\n        vec3 result = ambient + diffuse + specular;\r\n        FragColor = vec4(result, 1.0);\r\n    }\r\n    else{\r\n        FragColor = vec4(light.ambient * texture(material.diffuse, TexCoords).rgb, 1);\r\n    }\r\n}`;\r\nconst vsLightCube = `#version 300 es\r\nin vec3 aPos;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    gl_Position = projection * view * model * vec4(aPos, 1.0);    \r\n}`;\r\nconst fsLightCube = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nvoid main(){\r\n    FragColor = vec4(1.0);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.querySelector('#c');\r\n    const gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let camera = new _resources_camera__WEBPACK_IMPORTED_MODULE_2__[\"default\"]([0, 0, 3]);\r\n    let lastX = gl.canvas.width / 2;\r\n    let lastY = gl.canvas.height / 2;\r\n    let firstMouse = true;\r\n    let deltaTime = 0;\r\n    let lastFrame = 0;\r\n    let lightPos = [1.2, 1, 2];\r\n    let lightingShader = new _resources_Shader__WEBPACK_IMPORTED_MODULE_3__[\"default\"](gl, vsLightCasters, fsLightCasters);\r\n    let lightCubeShader = new _resources_Shader__WEBPACK_IMPORTED_MODULE_3__[\"default\"](gl, vsLightCube, fsLightCube);\r\n    let lightingPositionAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aPos');\r\n    let lightingNormalAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aNormal');\r\n    let lightingTexCoordsAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aTexCoords');\r\n    let lightCubePositionAttibLocation = gl.getAttribLocation(lightCubeShader.ID, 'aPos');\r\n    const vertices = [\r\n        // positions       // normals        // texture coords\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 0.0,\r\n        0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 1.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 1.0,\r\n        -0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, -0.5, -1.0, 0.0, 0.0, 1.0, 1.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, -1.0, 0.0, 0.0, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 0.0, 0.0, 1.0, 1.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0, 0.0, 0.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0, 1.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 1.0, 1.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 1.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 1.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 0.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.0, 1.0,\r\n        0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.0, 1.0\r\n    ];\r\n    const cubePositions = [\r\n        [0.0, 0.0, 0.0],\r\n        [2.0, 5.0, -15.0],\r\n        [-1.5, -2.2, -2.5],\r\n        [-3.8, -2.0, -12.3],\r\n        [2.4, -0.4, -3.5],\r\n        [-1.7, 3.0, -7.5],\r\n        [1.3, -2.0, -2.5],\r\n        [1.5, 2.0, -2.5],\r\n        [1.5, 0.2, -1.5],\r\n        [-1.3, 1.0, -1.5]\r\n    ];\r\n    // first, configure the cube's VAO (and VBO)\r\n    let cubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(cubeVAO);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(lightingPositionAttibLocation, 3, gl.FLOAT, false, 8 * 4, 0);\r\n    gl.enableVertexAttribArray(lightingPositionAttibLocation);\r\n    gl.vertexAttribPointer(lightingNormalAttibLocation, 3, gl.FLOAT, false, 8 * 4, 3 * 4);\r\n    gl.enableVertexAttribArray(lightingNormalAttibLocation);\r\n    gl.vertexAttribPointer(lightingTexCoordsAttibLocation, 2, gl.FLOAT, false, 8 * 4, 6 * 4);\r\n    gl.enableVertexAttribArray(lightingTexCoordsAttibLocation);\r\n    // second, configure the light's VAO (VBO stays the same; the vertices are the same for the light object which is also a 3D cube)\r\n    let lightCubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(lightCubeVAO);\r\n    gl.vertexAttribPointer(lightCubePositionAttibLocation, 3, gl.FLOAT, false, 8 * 4, 0);\r\n    gl.enableVertexAttribArray(lightCubePositionAttibLocation);\r\n    _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(canvas);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    // gl.useProgram(lightingShader);\r\n    lightingShader.use();\r\n    lightingShader.setInt('material.diffuse', 0);\r\n    lightingShader.setInt('material.specular', 1);\r\n    let imagePaths = [\"./resources/images/container2.png\", \"./resources/images/container2_specular.png\"];\r\n    const loadImage = function (imageSrc) {\r\n        let promise = new Promise((resolve, reject) => {\r\n            const image = new Image();\r\n            image.onload = () => {\r\n                resolve(image);\r\n            };\r\n            image.onerror = () => {\r\n                reject();\r\n            };\r\n            image.src = imageSrc;\r\n        });\r\n        return promise;\r\n    };\r\n    Promise.all(imagePaths.map(i => loadImage(i))).then(images => {\r\n        render(images);\r\n    });\r\n    function render(images) {\r\n        let textures = loadTexture(images);\r\n        textures.forEach((texture, index) => {\r\n            gl.activeTexture(gl.TEXTURE0 + index);\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        });\r\n        requestAnimationFrame(drawScene);\r\n        function drawScene(time) {\r\n            let currentFrame = time;\r\n            deltaTime = (currentFrame - lastFrame) * 0.001;\r\n            lastFrame = currentFrame;\r\n            gl.clearColor(0.1, 0.1, 0.1, 1.0);\r\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n            lightingShader.use();\r\n            lightingShader.setVec3('light.position', camera.Position);\r\n            lightingShader.setVec3('light.direction', camera.Front);\r\n            lightingShader.setFloat('light.cutOff', _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cos(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(12.5)));\r\n            lightingShader.setVec3('viewPos', camera.Position);\r\n            lightingShader.setVec3('light.ambient', 0.1, 0.1, 0.1);\r\n            lightingShader.setVec3('light.diffuse', 0.8, 0.8, 0.8);\r\n            lightingShader.setVec3('light.specular', 1, 1, 1);\r\n            lightingShader.setFloat('light.constant', 1);\r\n            lightingShader.setFloat('light.linear', 0.09);\r\n            lightingShader.setFloat('light.quadratic', 0.032);\r\n            lightingShader.setFloat('material.shininess', 32);\r\n            let glcanvas = gl.canvas;\r\n            let aspect = glcanvas.clientWidth / glcanvas.clientHeight;\r\n            let projection = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].perspective(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(camera.Zoom), aspect, 0.1, 100);\r\n            lightingShader.setMat4('projection', projection);\r\n            let view = camera.GetViewMatrix();\r\n            view = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].inverse(view);\r\n            lightingShader.setMat4('view', view);\r\n            let model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n            lightingShader.setMat4('model', model);\r\n            // render the cube\r\n            gl.bindVertexArray(cubeVAO);\r\n            for (let i = 0; i < cubePositions.length; i++) {\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(model, cubePositions[i]);\r\n                let angle = 20 * i;\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].axisRotate(model, [1, 0.3, 0.5], _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(angle));\r\n                lightingShader.setMat4(\"model\", model);\r\n                gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            }\r\n            // // also draw the lamp object\r\n            // lightCubeShader.use();\r\n            // lightCubeShader.setMat4('projection', projection);\r\n            // lightCubeShader.setMat4('view', view);\r\n            // model = glm.translate(model, lightPos);\r\n            // model = glm.scale(model, 0.2, 0.2, 0.2);\r\n            // lightCubeShader.setMat4('model', model);\r\n            // gl.bindVertexArray(lightCubeVAO);\r\n            // gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            requestAnimationFrame(drawScene);\r\n        }\r\n    }\r\n    function loadTexture(images) {\r\n        let textures = [];\r\n        for (let i = 0; i < images.length; i++) {\r\n            let image = images[i];\r\n            let texture = gl.createTexture();\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n            textures.push(texture);\r\n        }\r\n        return textures;\r\n    }\r\n    document.onkeydown = (event) => {\r\n        var e = event || window.event || arguments.callee.caller.arguments[0];\r\n        if (e && e.keyCode == 87) { // 按 W \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.FORWARD, deltaTime);\r\n            // console.log('wwwww');\r\n        }\r\n        else if (e && e.keyCode == 83) { // 按 S \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.BACKWARD, deltaTime);\r\n            // console.log('sssss');\r\n        }\r\n        else if (e && e.keyCode == 65) { // A\r\n            // console.log('aaaaa');\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.LEFT, deltaTime);\r\n        }\r\n        else if (e && e.keyCode == 68) { // D\r\n            // console.log('ddddd');\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.RIGHT, deltaTime);\r\n        }\r\n    };\r\n    canvas.onmousedown = (e) => {\r\n        lastX = e.clientX;\r\n        lastY = e.clientY;\r\n        fndown();\r\n    };\r\n    function fndown() {\r\n        canvas.onmousemove = (e) => {\r\n            let xpos = e.clientX;\r\n            let ypos = e.clientY;\r\n            if (firstMouse) {\r\n                lastX = xpos;\r\n                lastY = ypos;\r\n                firstMouse = false;\r\n            }\r\n            let xoffset = xpos - lastX;\r\n            let yoffset = lastY - ypos;\r\n            lastX = xpos;\r\n            lastY = ypos;\r\n            camera.ProcessMouseMovement(xoffset, yoffset);\r\n        };\r\n        canvas.onmouseup = (e) => {\r\n            canvas.onmousemove = null;\r\n            console.log(\"up\");\r\n        };\r\n    }\r\n    canvas.onwheel = (e) => {\r\n        let yoffset = e.deltaY;\r\n        camera.ProcessMouseSroll(yoffset);\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/2.lighting/09.light_casters_spot.ts?");

/***/ }),

/***/ "./src/2.lighting/10.light_casters_spot_soft.ts":
/*!******************************************************!*\
  !*** ./src/2.lighting/10.light_casters_spot_soft.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n/* harmony import */ var _resources_glm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/glm */ \"./src/resources/glm.ts\");\n/* harmony import */ var _resources_camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/camera */ \"./src/resources/camera.ts\");\n/* harmony import */ var _resources_Shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../resources/Shader */ \"./src/resources/Shader.ts\");\n\r\n\r\n\r\n\r\nconst vsLightCasters = `#version 300 es\r\n\r\nin vec3 aPos;\r\nin vec3 aNormal;\r\nin vec2 aTexCoords;\r\n\r\nout vec3 FragPos;\r\nout vec3 Normal;\r\nout vec2 TexCoords;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    FragPos = vec3(model * vec4(aPos, 1.0));\r\n    Normal = mat3(transpose(inverse(model))) * aNormal;\r\n    TexCoords = aTexCoords;\r\n\r\n    gl_Position = projection * view * vec4(FragPos, 1.0);\r\n}`;\r\nconst fsLightCasters = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nstruct Material{\r\n    sampler2D diffuse;\r\n    sampler2D specular;\r\n    float shininess;\r\n};\r\n\r\nstruct Light{\r\n    vec3 position;\r\n    vec3 direction;\r\n    float cutOff;\r\n    float outerCutOff;\r\n    \r\n    vec3 ambient;\r\n    vec3 diffuse;\r\n    vec3 specular;\r\n\r\n    float constant;\r\n    float linear;\r\n    float quadratic;\r\n};\r\n\r\nin vec3 Normal;\r\nin vec3 FragPos;\r\nin vec2 TexCoords;\r\n\r\nuniform vec3 viewPos;\r\nuniform Material material;\r\nuniform Light light;\r\n\r\nvoid main() {\r\n\r\n    // ambient\r\n    vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;\r\n\r\n    // diffuse\r\n    vec3 norm = normalize(Normal);\r\n    vec3 lightDir = normalize(light.position - FragPos);\r\n    float diff = max(dot(norm, lightDir), 0.0);\r\n    vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;\r\n\r\n    //specular\r\n    vec3 viewDir = normalize(viewPos - FragPos);\r\n    vec3 reflectDir = reflect(-lightDir, norm);\r\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\r\n    vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb;\r\n\r\n    //spotlight    \r\n    float theta = dot(lightDir, normalize(-light.direction));\r\n    float epsilon = light.cutOff - light.outerCutOff;\r\n    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);\r\n    diffuse *= intensity;\r\n    specular *= intensity;\r\n\r\n    // attenuation\r\n    float distance = length(light.position - FragPos);\r\n    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));\r\n    ambient *= attenuation;\r\n    diffuse *= attenuation;\r\n    specular *= attenuation;\r\n\r\n    vec3 result = ambient + diffuse + specular;\r\n    FragColor = vec4(result, 1.0);\r\n}`;\r\nconst vsLightCube = `#version 300 es\r\nin vec3 aPos;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    gl_Position = projection * view * model * vec4(aPos, 1.0);    \r\n}`;\r\nconst fsLightCube = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nvoid main(){\r\n    FragColor = vec4(1.0);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.querySelector('#c');\r\n    const gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let camera = new _resources_camera__WEBPACK_IMPORTED_MODULE_2__[\"default\"]([0, 0, 3]);\r\n    let lastX = gl.canvas.width / 2;\r\n    let lastY = gl.canvas.height / 2;\r\n    let firstMouse = true;\r\n    let deltaTime = 0;\r\n    let lastFrame = 0;\r\n    let lightPos = [1.2, 1, 2];\r\n    let lightingShader = new _resources_Shader__WEBPACK_IMPORTED_MODULE_3__[\"default\"](gl, vsLightCasters, fsLightCasters);\r\n    let lightCubeShader = new _resources_Shader__WEBPACK_IMPORTED_MODULE_3__[\"default\"](gl, vsLightCube, fsLightCube);\r\n    let lightingPositionAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aPos');\r\n    let lightingNormalAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aNormal');\r\n    let lightingTexCoordsAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aTexCoords');\r\n    let lightCubePositionAttibLocation = gl.getAttribLocation(lightCubeShader.ID, 'aPos');\r\n    const vertices = [\r\n        // positions       // normals        // texture coords\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 0.0,\r\n        0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 1.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 1.0,\r\n        -0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, -0.5, -1.0, 0.0, 0.0, 1.0, 1.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, -1.0, 0.0, 0.0, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 0.0, 0.0, 1.0, 1.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0, 0.0, 0.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0, 1.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 1.0, 1.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 1.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 1.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 0.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.0, 1.0,\r\n        0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.0, 1.0\r\n    ];\r\n    const cubePositions = [\r\n        [0.0, 0.0, 0.0],\r\n        [2.0, 5.0, -15.0],\r\n        [-1.5, -2.2, -2.5],\r\n        [-3.8, -2.0, -12.3],\r\n        [2.4, -0.4, -3.5],\r\n        [-1.7, 3.0, -7.5],\r\n        [1.3, -2.0, -2.5],\r\n        [1.5, 2.0, -2.5],\r\n        [1.5, 0.2, -1.5],\r\n        [-1.3, 1.0, -1.5]\r\n    ];\r\n    // first, configure the cube's VAO (and VBO)\r\n    let cubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(cubeVAO);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(lightingPositionAttibLocation, 3, gl.FLOAT, false, 8 * 4, 0);\r\n    gl.enableVertexAttribArray(lightingPositionAttibLocation);\r\n    gl.vertexAttribPointer(lightingNormalAttibLocation, 3, gl.FLOAT, false, 8 * 4, 3 * 4);\r\n    gl.enableVertexAttribArray(lightingNormalAttibLocation);\r\n    gl.vertexAttribPointer(lightingTexCoordsAttibLocation, 2, gl.FLOAT, false, 8 * 4, 6 * 4);\r\n    gl.enableVertexAttribArray(lightingTexCoordsAttibLocation);\r\n    // second, configure the light's VAO (VBO stays the same; the vertices are the same for the light object which is also a 3D cube)\r\n    let lightCubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(lightCubeVAO);\r\n    gl.vertexAttribPointer(lightCubePositionAttibLocation, 3, gl.FLOAT, false, 8 * 4, 0);\r\n    gl.enableVertexAttribArray(lightCubePositionAttibLocation);\r\n    _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(canvas);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    // gl.useProgram(lightingShader);\r\n    lightingShader.use();\r\n    lightingShader.setInt('material.diffuse', 0);\r\n    lightingShader.setInt('material.specular', 1);\r\n    let imagePaths = [\"./resources/images/container2.png\", \"./resources/images/container2_specular.png\"];\r\n    const loadImage = function (imageSrc) {\r\n        let promise = new Promise((resolve, reject) => {\r\n            const image = new Image();\r\n            image.onload = () => {\r\n                resolve(image);\r\n            };\r\n            image.onerror = () => {\r\n                reject();\r\n            };\r\n            image.src = imageSrc;\r\n        });\r\n        return promise;\r\n    };\r\n    Promise.all(imagePaths.map(i => loadImage(i))).then(images => {\r\n        render(images);\r\n    });\r\n    function render(images) {\r\n        let textures = loadTexture(images);\r\n        textures.forEach((texture, index) => {\r\n            gl.activeTexture(gl.TEXTURE0 + index);\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        });\r\n        requestAnimationFrame(drawScene);\r\n        function drawScene(time) {\r\n            let currentFrame = time;\r\n            deltaTime = (currentFrame - lastFrame) * 0.001;\r\n            lastFrame = currentFrame;\r\n            gl.clearColor(0.1, 0.1, 0.1, 1.0);\r\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n            lightingShader.use();\r\n            lightingShader.setVec3('light.position', camera.Position);\r\n            lightingShader.setVec3('light.direction', camera.Front);\r\n            lightingShader.setFloat('light.cutOff', _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cos(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(12.5)));\r\n            lightingShader.setFloat('light.outerCutOff', _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cos(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(17.5)));\r\n            lightingShader.setVec3('viewPos', camera.Position);\r\n            lightingShader.setVec3('light.ambient', 0.1, 0.1, 0.1);\r\n            lightingShader.setVec3('light.diffuse', 0.8, 0.8, 0.8);\r\n            lightingShader.setVec3('light.specular', 1, 1, 1);\r\n            lightingShader.setFloat('light.constant', 1);\r\n            lightingShader.setFloat('light.linear', 0.09);\r\n            lightingShader.setFloat('light.quadratic', 0.032);\r\n            lightingShader.setFloat('material.shininess', 32);\r\n            let glcanvas = gl.canvas;\r\n            let aspect = glcanvas.clientWidth / glcanvas.clientHeight;\r\n            let projection = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].perspective(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(camera.Zoom), aspect, 0.1, 100);\r\n            lightingShader.setMat4('projection', projection);\r\n            let view = camera.GetViewMatrix();\r\n            view = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].inverse(view);\r\n            lightingShader.setMat4('view', view);\r\n            let model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n            lightingShader.setMat4('model', model);\r\n            // render the cube\r\n            gl.bindVertexArray(cubeVAO);\r\n            for (let i = 0; i < cubePositions.length; i++) {\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(model, cubePositions[i]);\r\n                let angle = 20 * i;\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].axisRotate(model, [1, 0.3, 0.5], _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(angle));\r\n                lightingShader.setMat4(\"model\", model);\r\n                gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            }\r\n            // // also draw the lamp object\r\n            // lightCubeShader.use();\r\n            // lightCubeShader.setMat4('projection', projection);\r\n            // lightCubeShader.setMat4('view', view);\r\n            // model = glm.translate(model, lightPos);\r\n            // model = glm.scale(model, 0.2, 0.2, 0.2);\r\n            // lightCubeShader.setMat4('model', model);\r\n            // gl.bindVertexArray(lightCubeVAO);\r\n            // gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            requestAnimationFrame(drawScene);\r\n        }\r\n    }\r\n    function loadTexture(images) {\r\n        let textures = [];\r\n        for (let i = 0; i < images.length; i++) {\r\n            let image = images[i];\r\n            let texture = gl.createTexture();\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n            textures.push(texture);\r\n        }\r\n        return textures;\r\n    }\r\n    document.onkeydown = (event) => {\r\n        var e = event || window.event || arguments.callee.caller.arguments[0];\r\n        if (e && e.keyCode == 87) { // 按 W \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.FORWARD, deltaTime);\r\n            // console.log('wwwww');\r\n        }\r\n        else if (e && e.keyCode == 83) { // 按 S \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.BACKWARD, deltaTime);\r\n            // console.log('sssss');\r\n        }\r\n        else if (e && e.keyCode == 65) { // A\r\n            // console.log('aaaaa');\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.LEFT, deltaTime);\r\n        }\r\n        else if (e && e.keyCode == 68) { // D\r\n            // console.log('ddddd');\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.RIGHT, deltaTime);\r\n        }\r\n    };\r\n    canvas.onmousedown = (e) => {\r\n        lastX = e.clientX;\r\n        lastY = e.clientY;\r\n        fndown();\r\n    };\r\n    function fndown() {\r\n        canvas.onmousemove = (e) => {\r\n            let xpos = e.clientX;\r\n            let ypos = e.clientY;\r\n            if (firstMouse) {\r\n                lastX = xpos;\r\n                lastY = ypos;\r\n                firstMouse = false;\r\n            }\r\n            let xoffset = xpos - lastX;\r\n            let yoffset = lastY - ypos;\r\n            lastX = xpos;\r\n            lastY = ypos;\r\n            camera.ProcessMouseMovement(xoffset, yoffset);\r\n        };\r\n        canvas.onmouseup = (e) => {\r\n            canvas.onmousemove = null;\r\n            console.log(\"up\");\r\n        };\r\n    }\r\n    canvas.onwheel = (e) => {\r\n        let yoffset = e.deltaY;\r\n        camera.ProcessMouseSroll(yoffset);\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/2.lighting/10.light_casters_spot_soft.ts?");

/***/ }),

/***/ "./src/2.lighting/11.multiple_lights.ts":
/*!**********************************************!*\
  !*** ./src/2.lighting/11.multiple_lights.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources/webgl-utils */ \"./src/resources/webgl-utils.ts\");\n/* harmony import */ var _resources_glm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/glm */ \"./src/resources/glm.ts\");\n/* harmony import */ var _resources_camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/camera */ \"./src/resources/camera.ts\");\n/* harmony import */ var _resources_Shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../resources/Shader */ \"./src/resources/Shader.ts\");\n\r\n\r\n\r\n\r\nconst vsMultipleLights = `#version 300 es\r\n\r\nin vec3 aPos;\r\nin vec3 aNormal;\r\nin vec2 aTexCoords;\r\n\r\nout vec3 FragPos;\r\nout vec3 Normal;\r\nout vec2 TexCoords;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    FragPos = vec3(model * vec4(aPos, 1.0));\r\n    Normal = mat3(transpose(inverse(model))) * aNormal;\r\n    TexCoords = aTexCoords;\r\n\r\n    gl_Position = projection * view * vec4(FragPos, 1.0);\r\n}`;\r\nconst fsMultipleLights = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nstruct Material{\r\n    sampler2D diffuse;\r\n    sampler2D specular;\r\n    float shininess;\r\n};\r\n\r\nstruct DirLight{\r\n    vec3 direction;\r\n\r\n    vec3 ambient;\r\n    vec3 diffuse;\r\n    vec3 specular;\r\n};\r\n\r\nstruct PointLight{\r\n    vec3 position;\r\n\r\n    float constant;\r\n    float linear;\r\n    float quadratic;\r\n\r\n    vec3 ambient;\r\n    vec3 diffuse;\r\n    vec3 specular;\r\n};\r\n\r\nstruct SpotLight{\r\n    vec3 position;\r\n    vec3 direction;\r\n    float cutOff;\r\n    float outerCutOff;\r\n    \r\n    vec3 ambient;\r\n    vec3 diffuse;\r\n    vec3 specular;\r\n\r\n    float constant;\r\n    float linear;\r\n    float quadratic;\r\n};\r\n\r\n#define NR_POINT_LIGHTS 4\r\n\r\nin vec3 Normal;\r\nin vec3 FragPos;\r\nin vec2 TexCoords;\r\n\r\nuniform vec3 viewPos;\r\nuniform Material material;\r\nuniform DirLight dirLight;\r\nuniform PointLight pointLights[NR_POINT_LIGHTS];\r\nuniform SpotLight spotLight;\r\n\r\nvec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir);\r\nvec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);\r\nvec3 CalcSpotLight(SpotLight, vec3 normal, vec3 fragPos, vec3 viewDir);\r\n\r\nvoid main() {\r\n\r\n    // properties\r\n    vec3 norm = normalize(Normal);\r\n    vec3 viewDir = normalize(viewPos - FragPos);\r\n    \r\n    // == =====================================================\r\n    // Our lighting is set up in 3 phases: directional, point lights and an optional flashlight\r\n    // For each phase, a calculate function is defined that calculates the corresponding color\r\n    // per lamp. In the main() function we take all the calculated colors and sum them up for\r\n    // this fragment's final color.\r\n    // == =====================================================\r\n    // phase 1: directional lighting\r\n    vec3 result = CalcDirLight(dirLight, norm, viewDir);\r\n    // phase 2: point lights\r\n    for(int i = 0; i < NR_POINT_LIGHTS; i++)\r\n        result += CalcPointLight(pointLights[i], norm, FragPos, viewDir);    \r\n    // phase 3: spot light\r\n    result += CalcSpotLight(spotLight, norm, FragPos, viewDir);    \r\n    \r\n    FragColor = vec4(result, 1.0);\r\n}\r\n\r\n// calculates the color when using a directional light.\r\nvec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)\r\n{\r\n    vec3 lightDir = normalize(-light.direction);\r\n    // diffuse shading\r\n    float diff = max(dot(normal, lightDir), 0.0);\r\n    // specular shading\r\n    vec3 reflectDir = reflect(-lightDir, normal);\r\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\r\n    // combine results\r\n    vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords));\r\n    vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords));\r\n    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));\r\n    return (ambient + diffuse + specular);\r\n}\r\n\r\n// calculates the color when using a point light.\r\nvec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)\r\n{\r\n    vec3 lightDir = normalize(light.position - fragPos);\r\n    // diffuse shading\r\n    float diff = max(dot(normal, lightDir), 0.0);\r\n    // specular shading\r\n    vec3 reflectDir = reflect(-lightDir, normal);\r\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\r\n    // attenuation\r\n    float distance = length(light.position - fragPos);\r\n    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    \r\n    // combine results\r\n    vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords));\r\n    vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords));\r\n    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));\r\n    ambient *= attenuation;\r\n    diffuse *= attenuation;\r\n    specular *= attenuation;\r\n    return (ambient + diffuse + specular);\r\n}\r\n\r\n// calculates the color when using a spot light.\r\nvec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)\r\n{\r\n    vec3 lightDir = normalize(light.position - fragPos);\r\n    // diffuse shading\r\n    float diff = max(dot(normal, lightDir), 0.0);\r\n    // specular shading\r\n    vec3 reflectDir = reflect(-lightDir, normal);\r\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\r\n    // attenuation\r\n    float distance = length(light.position - fragPos);\r\n    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    \r\n    // spotlight intensity\r\n    float theta = dot(lightDir, normalize(-light.direction)); \r\n    float epsilon = light.cutOff - light.outerCutOff;\r\n    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);\r\n    // combine results\r\n    vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords));\r\n    vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords));\r\n    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));\r\n    ambient *= attenuation * intensity;\r\n    diffuse *= attenuation * intensity;\r\n    specular *= attenuation * intensity;\r\n    return (ambient + diffuse + specular);\r\n}`;\r\nconst vsLightCube = `#version 300 es\r\nin vec3 aPos;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nvoid main(){\r\n    gl_Position = projection * view * model * vec4(aPos, 1.0);    \r\n}`;\r\nconst fsLightCube = `#version 300 es\r\nprecision highp float;\r\nout vec4 FragColor;\r\n\r\nvoid main(){\r\n    FragColor = vec4(1.0);\r\n}`;\r\nfunction main() {\r\n    const canvas = document.querySelector('#c');\r\n    const gl = canvas.getContext('webgl2');\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    let camera = new _resources_camera__WEBPACK_IMPORTED_MODULE_2__[\"default\"]([0, 0, 3]);\r\n    let lastX = gl.canvas.width / 2;\r\n    let lastY = gl.canvas.height / 2;\r\n    let firstMouse = true;\r\n    let deltaTime = 0;\r\n    let lastFrame = 0;\r\n    let lightPos = [1.2, 1, 2];\r\n    let lightingShader = new _resources_Shader__WEBPACK_IMPORTED_MODULE_3__[\"default\"](gl, vsMultipleLights, fsMultipleLights);\r\n    let lightCubeShader = new _resources_Shader__WEBPACK_IMPORTED_MODULE_3__[\"default\"](gl, vsLightCube, fsLightCube);\r\n    let lightingPositionAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aPos');\r\n    let lightingNormalAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aNormal');\r\n    let lightingTexCoordsAttibLocation = gl.getAttribLocation(lightingShader.ID, 'aTexCoords');\r\n    let lightCubePositionAttibLocation = gl.getAttribLocation(lightCubeShader.ID, 'aPos');\r\n    const vertices = [\r\n        // positions       // normals        // texture coords\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 0.0,\r\n        0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 1.0,\r\n        0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 1.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, 0.0, 0.0, -1.0, 0.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 1.0, 1.0,\r\n        -0.5, 0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, 0.0, 0.0, 1.0, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, -0.5, -1.0, 0.0, 0.0, 1.0, 1.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0, 0.0, 1.0,\r\n        -0.5, -0.5, -0.5, -1.0, 0.0, 0.0, 0.0, 1.0,\r\n        -0.5, -0.5, 0.5, -1.0, 0.0, 0.0, 0.0, 0.0,\r\n        -0.5, 0.5, 0.5, -1.0, 0.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, -0.5, 1.0, 0.0, 0.0, 1.0, 1.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 1.0, 0.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, 0.5, 1.0, 0.0, 0.0, 0.0, 0.0,\r\n        0.5, 0.5, 0.5, 1.0, 0.0, 0.0, 1.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 0.0, 1.0,\r\n        0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 1.0, 1.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 1.0, 0.0,\r\n        0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 1.0, 0.0,\r\n        -0.5, -0.5, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0,\r\n        -0.5, -0.5, -0.5, 0.0, -1.0, 0.0, 0.0, 1.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.0, 1.0,\r\n        0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 1.0, 1.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 1.0, 0.0,\r\n        0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 1.0, 0.0,\r\n        -0.5, 0.5, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0,\r\n        -0.5, 0.5, -0.5, 0.0, 1.0, 0.0, 0.0, 1.0\r\n    ];\r\n    const cubePositions = [\r\n        [0.0, 0.0, 0.0],\r\n        [2.0, 5.0, -15.0],\r\n        [-1.5, -2.2, -2.5],\r\n        [-3.8, -2.0, -12.3],\r\n        [2.4, -0.4, -3.5],\r\n        [-1.7, 3.0, -7.5],\r\n        [1.3, -2.0, -2.5],\r\n        [1.5, 2.0, -2.5],\r\n        [1.5, 0.2, -1.5],\r\n        [-1.3, 1.0, -1.5]\r\n    ];\r\n    const pointLightPositions = [\r\n        [0.7, 0.2, 2.0],\r\n        [2.3, -3.3, -4.0],\r\n        [-4.0, 2.0, -12.0],\r\n        [0.0, 0.0, -3.0]\r\n    ];\r\n    // first, configure the cube's VAO (and VBO)\r\n    let cubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(cubeVAO);\r\n    let vbo = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(lightingPositionAttibLocation, 3, gl.FLOAT, false, 8 * 4, 0);\r\n    gl.enableVertexAttribArray(lightingPositionAttibLocation);\r\n    gl.vertexAttribPointer(lightingNormalAttibLocation, 3, gl.FLOAT, false, 8 * 4, 3 * 4);\r\n    gl.enableVertexAttribArray(lightingNormalAttibLocation);\r\n    gl.vertexAttribPointer(lightingTexCoordsAttibLocation, 2, gl.FLOAT, false, 8 * 4, 6 * 4);\r\n    gl.enableVertexAttribArray(lightingTexCoordsAttibLocation);\r\n    // second, configure the light's VAO (VBO stays the same; the vertices are the same for the light object which is also a 3D cube)\r\n    let lightCubeVAO = gl.createVertexArray();\r\n    gl.bindVertexArray(lightCubeVAO);\r\n    gl.vertexAttribPointer(lightCubePositionAttibLocation, 3, gl.FLOAT, false, 8 * 4, 0);\r\n    gl.enableVertexAttribArray(lightCubePositionAttibLocation);\r\n    _resources_webgl_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resizeCanvasToDisplaySize(canvas);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    // gl.useProgram(lightingShader);\r\n    lightingShader.use();\r\n    lightingShader.setInt('material.diffuse', 0);\r\n    lightingShader.setInt('material.specular', 1);\r\n    lightingShader.setFloat('material.shininess', 32);\r\n    let imagePaths = [\"./resources/images/container2.png\", \"./resources/images/container2_specular.png\"];\r\n    const loadImage = function (imageSrc) {\r\n        let promise = new Promise((resolve, reject) => {\r\n            const image = new Image();\r\n            image.onload = () => {\r\n                resolve(image);\r\n            };\r\n            image.onerror = () => {\r\n                reject();\r\n            };\r\n            image.src = imageSrc;\r\n        });\r\n        return promise;\r\n    };\r\n    Promise.all(imagePaths.map(i => loadImage(i))).then(images => {\r\n        render(images);\r\n    });\r\n    function render(images) {\r\n        let textures = loadTexture(images);\r\n        textures.forEach((texture, index) => {\r\n            gl.activeTexture(gl.TEXTURE0 + index);\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        });\r\n        requestAnimationFrame(drawScene);\r\n        function drawScene(time) {\r\n            let currentFrame = time;\r\n            deltaTime = (currentFrame - lastFrame) * 0.001;\r\n            lastFrame = currentFrame;\r\n            gl.clearColor(0.1, 0.1, 0.1, 1.0);\r\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n            lightingShader.use();\r\n            lightingShader.setVec3('viewPos', camera.Position);\r\n            /*\r\n            Here we set all the uniforms for the 5/6 types of lights we have. We have to set them manually and index\r\n            the proper PointLight struct in the array to set each uniform variable. This can be done more code-friendly\r\n            by defining light types as classes and set their values in there, or by using a more efficient uniform approach\r\n            by using 'Uniform buffer objects', but that is something we'll discuss in the 'Advanced GLSL' tutorial.\r\n            */\r\n            // directional light\r\n            lightingShader.setVec3(\"dirLight.direction\", -0.2, -1, -0.3);\r\n            lightingShader.setVec3(\"dirLight.ambient\", 0.05, 0.05, 0.05);\r\n            lightingShader.setVec3(\"dirLight.diffuse\", 0.4, 0.4, 0.4);\r\n            lightingShader.setVec3(\"dirLight.specular\", 0.5, 0.5, 0.5);\r\n            // point light 1\r\n            lightingShader.setVec3(\"pointLights[0].position\", pointLightPositions[0]);\r\n            lightingShader.setVec3(\"pointLights[0].ambient\", 0.05, 0.05, 0.05);\r\n            lightingShader.setVec3(\"pointLights[0].diffuse\", 0.8, 0.8, 0.8);\r\n            lightingShader.setVec3(\"pointLights[0].specular\", 1, 1, 1);\r\n            lightingShader.setFloat(\"pointLights[0].constant\", 1);\r\n            lightingShader.setFloat(\"pointLights[0].linear\", 0.09);\r\n            lightingShader.setFloat(\"pointLights[0].quadratic\", 0.032);\r\n            // point light 2\r\n            lightingShader.setVec3(\"pointLights[1].position\", pointLightPositions[1]);\r\n            lightingShader.setVec3(\"pointLights[1].ambient\", 0.05, 0.05, 0.05);\r\n            lightingShader.setVec3(\"pointLights[1].diffuse\", 0.8, 0.8, 0.8);\r\n            lightingShader.setVec3(\"pointLights[1].specular\", 1, 1, 1);\r\n            lightingShader.setFloat(\"pointLights[1].constant\", 1);\r\n            lightingShader.setFloat(\"pointLights[1].linear\", 0.09);\r\n            lightingShader.setFloat(\"pointLights[1].quadratic\", 0.032);\r\n            // point light 3\r\n            lightingShader.setVec3(\"pointLights[2].position\", pointLightPositions[2]);\r\n            lightingShader.setVec3(\"pointLights[2].ambient\", 0.05, 0.05, 0.05);\r\n            lightingShader.setVec3(\"pointLights[2].diffuse\", 0.8, 0.8, 0.8);\r\n            lightingShader.setVec3(\"pointLights[2].specular\", 1, 1, 1);\r\n            lightingShader.setFloat(\"pointLights[2].constant\", 1);\r\n            lightingShader.setFloat(\"pointLights[2].linear\", 0.09);\r\n            lightingShader.setFloat(\"pointLights[2].quadratic\", 0.032);\r\n            // point light 4\r\n            lightingShader.setVec3(\"pointLights[3].position\", pointLightPositions[3]);\r\n            lightingShader.setVec3(\"pointLights[3].ambient\", 0.05, 0.05, 0.05);\r\n            lightingShader.setVec3(\"pointLights[3].diffuse\", 0.8, 0.8, 0.8);\r\n            lightingShader.setVec3(\"pointLights[3].specular\", 1, 1, 1);\r\n            lightingShader.setFloat(\"pointLights[3].constant\", 1);\r\n            lightingShader.setFloat(\"pointLights[3].linear\", 0.09);\r\n            lightingShader.setFloat(\"pointLights[3].quadratic\", 0.032);\r\n            // spotLight\r\n            lightingShader.setVec3(\"spotLight.position\", camera.Position);\r\n            lightingShader.setVec3(\"spotLight.direction\", camera.Front);\r\n            lightingShader.setVec3(\"spotLight.ambient\", 0, 0, 0);\r\n            lightingShader.setVec3(\"spotLight.diffuse\", 1, 1, 1);\r\n            lightingShader.setVec3(\"spotLight.specular\", 1, 1, 1);\r\n            lightingShader.setFloat(\"spotLight.constant\", 1);\r\n            lightingShader.setFloat(\"spotLight.linear\", 0.09);\r\n            lightingShader.setFloat(\"spotLight.quadratic\", 0.032);\r\n            lightingShader.setFloat(\"spotLight.cutOff\", _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cos(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(12.5)));\r\n            lightingShader.setFloat(\"spotLight.outerCutOff\", _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cos(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(15)));\r\n            let glcanvas = gl.canvas;\r\n            let aspect = glcanvas.clientWidth / glcanvas.clientHeight;\r\n            let projection = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].perspective(_resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(camera.Zoom), aspect, 0.1, 100);\r\n            lightingShader.setMat4('projection', projection);\r\n            let view = camera.GetViewMatrix();\r\n            view = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].inverse(view);\r\n            lightingShader.setMat4('view', view);\r\n            let model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n            lightingShader.setMat4('model', model);\r\n            // render the cube\r\n            gl.bindVertexArray(cubeVAO);\r\n            for (let i = 0; i < cubePositions.length; i++) {\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].identity();\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(model, cubePositions[i]);\r\n                let angle = 20 * i;\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].axisRotate(model, [1, 0.3, 0.5], _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radians(angle));\r\n                lightingShader.setMat4(\"model\", model);\r\n                gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            }\r\n            // also draw the lamp object\r\n            lightCubeShader.use();\r\n            lightCubeShader.setMat4('projection', projection);\r\n            lightCubeShader.setMat4('view', view);\r\n            gl.bindVertexArray(lightCubeVAO);\r\n            for (let i = 0; i < 4; i++) {\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(model, lightPos);\r\n                model = _resources_glm__WEBPACK_IMPORTED_MODULE_1__[\"default\"].scale(model, 0.2, 0.2, 0.2);\r\n                lightCubeShader.setMat4('model', model);\r\n                gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            }\r\n            requestAnimationFrame(drawScene);\r\n        }\r\n    }\r\n    function loadTexture(images) {\r\n        let textures = [];\r\n        for (let i = 0; i < images.length; i++) {\r\n            let image = images[i];\r\n            let texture = gl.createTexture();\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n            textures.push(texture);\r\n        }\r\n        return textures;\r\n    }\r\n    document.onkeydown = (event) => {\r\n        var e = event || window.event || arguments.callee.caller.arguments[0];\r\n        if (e && e.keyCode == 87) { // 按 W \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.FORWARD, deltaTime);\r\n            // console.log('wwwww');\r\n        }\r\n        else if (e && e.keyCode == 83) { // 按 S \r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.BACKWARD, deltaTime);\r\n            // console.log('sssss');\r\n        }\r\n        else if (e && e.keyCode == 65) { // A\r\n            // console.log('aaaaa');\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.LEFT, deltaTime);\r\n        }\r\n        else if (e && e.keyCode == 68) { // D\r\n            // console.log('ddddd');\r\n            camera.ProcessKeyboard(_resources_camera__WEBPACK_IMPORTED_MODULE_2__.Camera_Movement.RIGHT, deltaTime);\r\n        }\r\n    };\r\n    canvas.onmousedown = (e) => {\r\n        lastX = e.clientX;\r\n        lastY = e.clientY;\r\n        fndown();\r\n    };\r\n    function fndown() {\r\n        canvas.onmousemove = (e) => {\r\n            let xpos = e.clientX;\r\n            let ypos = e.clientY;\r\n            if (firstMouse) {\r\n                lastX = xpos;\r\n                lastY = ypos;\r\n                firstMouse = false;\r\n            }\r\n            let xoffset = xpos - lastX;\r\n            let yoffset = lastY - ypos;\r\n            lastX = xpos;\r\n            lastY = ypos;\r\n            camera.ProcessMouseMovement(xoffset, yoffset);\r\n        };\r\n        canvas.onmouseup = (e) => {\r\n            canvas.onmousemove = null;\r\n            console.log(\"up\");\r\n        };\r\n    }\r\n    canvas.onwheel = (e) => {\r\n        let yoffset = e.deltaY;\r\n        camera.ProcessMouseSroll(yoffset);\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/2.lighting/11.multiple_lights.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"basic_lighting_diffuse\": () => (/* reexport safe */ _2_lighting_02_basic_lighting_diffuse__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   \"basic_lighting_specula\": () => (/* reexport safe */ _2_lighting_03_basic_lighting_specular__WEBPACK_IMPORTED_MODULE_11__[\"default\"]),\n/* harmony export */   \"camera_circle\": () => (/* reexport safe */ _1_getting_started_b_camera_circle__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   \"camera_keyboard_dt\": () => (/* reexport safe */ _1_getting_started_c_camera_keyboard_dt__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   \"camera_mouse_zoom\": () => (/* reexport safe */ _1_getting_started_d_camera_mouse_zoom__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   \"colors\": () => (/* reexport safe */ _2_lighting_01_colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   \"coordinate_system_depth\": () => (/* reexport safe */ _1_getting_started_9_coordinate_system_depth__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   \"coordinate_system_multiple\": () => (/* reexport safe */ _1_getting_started_a_coordinate_system_multiple__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   \"hello_triangle\": () => (/* reexport safe */ _1_getting_started_1_hello_triangle__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"hello_triangle_indexed\": () => (/* reexport safe */ _1_getting_started_2_hello_triangle_indexed__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   \"light_casters_directional\": () => (/* reexport safe */ _2_lighting_07_light_casters_directional__WEBPACK_IMPORTED_MODULE_15__[\"default\"]),\n/* harmony export */   \"light_casters_point\": () => (/* reexport safe */ _2_lighting_08_light_casters_point__WEBPACK_IMPORTED_MODULE_16__[\"default\"]),\n/* harmony export */   \"light_casters_spot\": () => (/* reexport safe */ _2_lighting_09_light_casters_spot__WEBPACK_IMPORTED_MODULE_17__[\"default\"]),\n/* harmony export */   \"light_casters_spot_soft\": () => (/* reexport safe */ _2_lighting_10_light_casters_spot_soft__WEBPACK_IMPORTED_MODULE_18__[\"default\"]),\n/* harmony export */   \"lighting_maps_diffuse\": () => (/* reexport safe */ _2_lighting_05_lighting_maps_diffuse__WEBPACK_IMPORTED_MODULE_13__[\"default\"]),\n/* harmony export */   \"lighting_maps_specular\": () => (/* reexport safe */ _2_lighting_06_lighting_maps_specular__WEBPACK_IMPORTED_MODULE_14__[\"default\"]),\n/* harmony export */   \"materials\": () => (/* reexport safe */ _2_lighting_04_materials__WEBPACK_IMPORTED_MODULE_12__[\"default\"]),\n/* harmony export */   \"multiple_lights\": () => (/* reexport safe */ _2_lighting_11_multiple_lights__WEBPACK_IMPORTED_MODULE_19__[\"default\"]),\n/* harmony export */   \"textures\": () => (/* reexport safe */ _1_getting_started_5_textures__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   \"textures_combine\": () => (/* reexport safe */ _1_getting_started_6_textures_combine__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _1_getting_started_1_hello_triangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./1.getting_started/1.hello_triangle */ \"./src/1.getting_started/1.hello_triangle.ts\");\n/* harmony import */ var _1_getting_started_2_hello_triangle_indexed__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./1.getting_started/2.hello_triangle_indexed */ \"./src/1.getting_started/2.hello_triangle_indexed.ts\");\n/* harmony import */ var _1_getting_started_5_textures__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./1.getting_started/5.textures */ \"./src/1.getting_started/5.textures.ts\");\n/* harmony import */ var _1_getting_started_6_textures_combine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./1.getting_started/6.textures_combine */ \"./src/1.getting_started/6.textures_combine.ts\");\n/* harmony import */ var _1_getting_started_9_coordinate_system_depth__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./1.getting_started/9.coordinate_system_depth */ \"./src/1.getting_started/9.coordinate_system_depth.ts\");\n/* harmony import */ var _1_getting_started_a_coordinate_system_multiple__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./1.getting_started/a.coordinate_system_multiple */ \"./src/1.getting_started/a.coordinate_system_multiple.ts\");\n/* harmony import */ var _1_getting_started_b_camera_circle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./1.getting_started/b.camera_circle */ \"./src/1.getting_started/b.camera_circle.ts\");\n/* harmony import */ var _1_getting_started_c_camera_keyboard_dt__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./1.getting_started/c.camera_keyboard_dt */ \"./src/1.getting_started/c.camera_keyboard_dt.ts\");\n/* harmony import */ var _1_getting_started_d_camera_mouse_zoom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./1.getting_started/d.camera_mouse_zoom */ \"./src/1.getting_started/d.camera_mouse_zoom.ts\");\n/* harmony import */ var _2_lighting_01_colors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./2.lighting/01.colors */ \"./src/2.lighting/01.colors.ts\");\n/* harmony import */ var _2_lighting_02_basic_lighting_diffuse__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./2.lighting/02.basic_lighting_diffuse */ \"./src/2.lighting/02.basic_lighting_diffuse.ts\");\n/* harmony import */ var _2_lighting_03_basic_lighting_specular__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./2.lighting/03.basic_lighting_specular */ \"./src/2.lighting/03.basic_lighting_specular.ts\");\n/* harmony import */ var _2_lighting_04_materials__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./2.lighting/04.materials */ \"./src/2.lighting/04.materials.ts\");\n/* harmony import */ var _2_lighting_05_lighting_maps_diffuse__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./2.lighting/05.lighting_maps_diffuse */ \"./src/2.lighting/05.lighting_maps_diffuse.ts\");\n/* harmony import */ var _2_lighting_06_lighting_maps_specular__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./2.lighting/06.lighting_maps_specular */ \"./src/2.lighting/06.lighting_maps_specular.ts\");\n/* harmony import */ var _2_lighting_07_light_casters_directional__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./2.lighting/07.light_casters_directional */ \"./src/2.lighting/07.light_casters_directional.ts\");\n/* harmony import */ var _2_lighting_08_light_casters_point__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./2.lighting/08.light_casters_point */ \"./src/2.lighting/08.light_casters_point.ts\");\n/* harmony import */ var _2_lighting_09_light_casters_spot__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./2.lighting/09.light_casters_spot */ \"./src/2.lighting/09.light_casters_spot.ts\");\n/* harmony import */ var _2_lighting_10_light_casters_spot_soft__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./2.lighting/10.light_casters_spot_soft */ \"./src/2.lighting/10.light_casters_spot_soft.ts\");\n/* harmony import */ var _2_lighting_11_multiple_lights__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./2.lighting/11.multiple_lights */ \"./src/2.lighting/11.multiple_lights.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/index.ts?");

/***/ }),

/***/ "./src/resources/Shader.ts":
/*!*********************************!*\
  !*** ./src/resources/Shader.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ shader)\n/* harmony export */ });\nclass shader {\r\n    constructor(gl, vertexSource, fragmentSource) {\r\n        this.gl = gl;\r\n        let vertexShader = this.loadShader(gl, vertexSource, gl.VERTEX_SHADER);\r\n        let fragmentShader = this.loadShader(gl, fragmentSource, gl.FRAGMENT_SHADER);\r\n        this.ID = this.createProgram(gl, vertexShader, fragmentShader);\r\n    }\r\n    createProgram(gl, vertex, fragment) {\r\n        let program = gl.createProgram();\r\n        gl.attachShader(program, vertex);\r\n        gl.attachShader(program, fragment);\r\n        gl.linkProgram(program);\r\n        var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n        if (!linked) {\r\n            // something went wrong with the link\r\n            var lastError = gl.getProgramInfoLog(program);\r\n            console.error(\"Error in program linking:\" + lastError);\r\n            gl.deleteProgram(program);\r\n            return null;\r\n        }\r\n        return program;\r\n    }\r\n    loadShader(gl, shaderSource, shaderType) {\r\n        var shader = gl.createShader(shaderType);\r\n        gl.shaderSource(shader, shaderSource);\r\n        gl.compileShader(shader);\r\n        var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n        if (!compiled) {\r\n            // Something went wrong during compilation; get the error\r\n            var lastError = gl.getShaderInfoLog(shader);\r\n            console.error(\"*** Error compiling shader '\" + shader + \"':\" + lastError);\r\n            gl.deleteShader(shader);\r\n            return null;\r\n        }\r\n        return shader;\r\n    }\r\n    use() {\r\n        this.gl.useProgram(this.ID);\r\n    }\r\n    /**\r\n     * setBool\r\n     */\r\n    setBool(name, value) {\r\n        let location = this.gl.getUniformLocation(this.ID, name);\r\n        this.gl.uniform1i(location, Number(value));\r\n    }\r\n    /**\r\n     * setInt\r\n     */\r\n    setInt(name, value) {\r\n        let location = this.gl.getUniformLocation(this.ID, name);\r\n        this.gl.uniform1i(location, value);\r\n    }\r\n    setFloat(name, value) {\r\n        let location = this.gl.getUniformLocation(this.ID, name);\r\n        this.gl.uniform1f(location, value);\r\n    }\r\n    /**\r\n     * setVec2\r\n     */\r\n    setVec2(name, value, value2) {\r\n        let location = this.gl.getUniformLocation(this.ID, name);\r\n        if (typeof value == 'number') {\r\n            this.gl.uniform2f(location, value, value2);\r\n        }\r\n        else {\r\n            this.gl.uniform2fv(location, value);\r\n        }\r\n    }\r\n    /**\r\n     * setVec3\r\n     */\r\n    setVec3(name, value, value2, value3) {\r\n        let location = this.gl.getUniformLocation(this.ID, name);\r\n        if (typeof value == 'number') {\r\n            this.gl.uniform3f(location, value, value2, value3);\r\n        }\r\n        else {\r\n            this.gl.uniform3fv(location, value);\r\n        }\r\n    }\r\n    /**\r\n     * setVec4\r\n     */\r\n    setVec4(name, value, value2, value3, value4) {\r\n        let location = this.gl.getUniformLocation(this.ID, name);\r\n        if (typeof value == 'number') {\r\n            this.gl.uniform4f(location, value, value2, value3, value4);\r\n        }\r\n        else {\r\n            this.gl.uniform4fv(location, value);\r\n        }\r\n    }\r\n    /**\r\n     * setMat2\r\n     */\r\n    setMat2(name, value) {\r\n        let location = this.gl.getUniformLocation(this.ID, name);\r\n        this.gl.uniformMatrix2fv(location, false, value);\r\n    }\r\n    /**\r\n     * setMat3\r\n     */\r\n    setMat3(name, value) {\r\n        let location = this.gl.getUniformLocation(this.ID, name);\r\n        this.gl.uniformMatrix3fv(location, false, value);\r\n    }\r\n    /**\r\n     * setMat4\r\n     */\r\n    setMat4(name, value) {\r\n        let location = this.gl.getUniformLocation(this.ID, name);\r\n        this.gl.uniformMatrix4fv(location, false, value);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/resources/Shader.ts?");

/***/ }),

/***/ "./src/resources/camera.ts":
/*!*********************************!*\
  !*** ./src/resources/camera.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Camera_Movement\": () => (/* binding */ Camera_Movement),\n/* harmony export */   \"default\": () => (/* binding */ Camera)\n/* harmony export */ });\n/* harmony import */ var _glm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glm */ \"./src/resources/glm.ts\");\n/* harmony import */ var _glMatrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glMatrix */ \"./src/resources/glMatrix/index.ts\");\n\r\n\r\nconst YAW = -90;\r\nconst PITCH = 0;\r\nconst SPEED = 2.5;\r\nconst SENSITIVITY = 0.1;\r\nconst ZOOM = 45;\r\nvar Camera_Movement;\r\n(function (Camera_Movement) {\r\n    Camera_Movement[Camera_Movement[\"FORWARD\"] = 0] = \"FORWARD\";\r\n    Camera_Movement[Camera_Movement[\"BACKWARD\"] = 1] = \"BACKWARD\";\r\n    Camera_Movement[Camera_Movement[\"LEFT\"] = 2] = \"LEFT\";\r\n    Camera_Movement[Camera_Movement[\"RIGHT\"] = 3] = \"RIGHT\";\r\n})(Camera_Movement || (Camera_Movement = {}));\r\n;\r\nclass Camera {\r\n    constructor(position = [0, 0, 0], up = [0, 1, 0], yaw = YAW, pitch = PITCH) {\r\n        this.Front = [0, 0, -1];\r\n        this.MovementSpeed = SPEED;\r\n        this.MouseSensitivity = SENSITIVITY;\r\n        this.Zoom = ZOOM;\r\n        this.Position = position;\r\n        this.WorldUp = up;\r\n        this.Yaw = yaw;\r\n        this.Pitch = pitch;\r\n        this.updateCameraVector();\r\n    }\r\n    GetViewMatrix() {\r\n        return _glm__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lookAt(this.Position, _glm__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Position, this.Front), this.Up);\r\n    }\r\n    ProcessKeyboard(direction, deltaTime) {\r\n        let velociy = this.MovementSpeed * deltaTime;\r\n        if (direction == Camera_Movement.FORWARD) {\r\n            // this.Position += this.Front * velociy;\r\n            this.Position = _glMatrix__WEBPACK_IMPORTED_MODULE_1__.vec3.add(this.Position, _glMatrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scale(this.Front, velociy));\r\n        }\r\n        if (direction == Camera_Movement.BACKWARD) {\r\n            this.Position = _glMatrix__WEBPACK_IMPORTED_MODULE_1__.vec3.subtract(this.Position, _glMatrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scale(this.Front, velociy));\r\n        }\r\n        if (direction == Camera_Movement.LEFT) {\r\n            this.Position = _glMatrix__WEBPACK_IMPORTED_MODULE_1__.vec3.subtract(this.Position, _glMatrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scale(this.Right, velociy));\r\n        }\r\n        if (direction == Camera_Movement.RIGHT) {\r\n            this.Position = _glMatrix__WEBPACK_IMPORTED_MODULE_1__.vec3.add(this.Position, _glMatrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scale(this.Right, velociy));\r\n        }\r\n    }\r\n    ProcessMouseMovement(xoffset, yoffset, constrainPitch = true) {\r\n        xoffset *= this.MouseSensitivity;\r\n        yoffset *= this.MouseSensitivity;\r\n        this.Yaw += xoffset;\r\n        this.Pitch += yoffset;\r\n        if (constrainPitch) {\r\n            if (this.Pitch > 89) {\r\n                this.Pitch = 89;\r\n            }\r\n            if (this.Pitch < -89) {\r\n                this.Pitch = -89;\r\n            }\r\n        }\r\n        this.updateCameraVector();\r\n    }\r\n    ProcessMouseSroll(yoffset) {\r\n        this.Zoom -= yoffset;\r\n        if (this.Zoom < 1) {\r\n            this.Zoom = 1;\r\n        }\r\n        if (this.Zoom > 45) {\r\n            this.Zoom = 45;\r\n        }\r\n    }\r\n    updateCameraVector() {\r\n        let front = _glMatrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();\r\n        front[0] = Math.cos(_glm__WEBPACK_IMPORTED_MODULE_0__[\"default\"].radians(this.Yaw)) * Math.cos(_glm__WEBPACK_IMPORTED_MODULE_0__[\"default\"].radians(this.Pitch));\r\n        front[1] = Math.sin(_glm__WEBPACK_IMPORTED_MODULE_0__[\"default\"].radians(this.Pitch));\r\n        front[2] = Math.sin(_glm__WEBPACK_IMPORTED_MODULE_0__[\"default\"].radians(this.Yaw)) * Math.cos(_glm__WEBPACK_IMPORTED_MODULE_0__[\"default\"].radians(this.Pitch));\r\n        this.Front = _glm__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalize(front);\r\n        this.Right = _glm__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalize(_glm__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cross(this.Front, this.WorldUp));\r\n        this.Up = _glm__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalize(_glm__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cross(this.Right, this.Front));\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/resources/camera.ts?");

/***/ }),

/***/ "./src/resources/glMatrix/gl-matrix.ts":
/*!*********************************************!*\
  !*** ./src/resources/glMatrix/gl-matrix.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass GLMatrix {\r\n    constructor() {\r\n        this.degree = Math.PI / 180;\r\n        this.EPSILON = 0.000001;\r\n        this.ARRAY_TYPE = typeof Float32Array !== \"undefined\" ? Float32Array : Array;\r\n        this.RANDOM = Math.random;\r\n        this.ENABLE_SIMD = false;\r\n        this.SIMD_AVAILABLE = this.ARRAY_TYPE === Float32Array && \"SIMD\" in this;\r\n        this.USE_SIMD = this.ENABLE_SIMD && this.SIMD_AVAILABLE;\r\n    }\r\n    setMatrixArrayType(type) {\r\n        this.ARRAY_TYPE = type;\r\n    }\r\n    toRadian(a) {\r\n        return a * this.degree;\r\n    }\r\n}\r\nconst glMatrix = new GLMatrix();\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (glMatrix);\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/resources/glMatrix/gl-matrix.ts?");

/***/ }),

/***/ "./src/resources/glMatrix/index.ts":
/*!*****************************************!*\
  !*** ./src/resources/glMatrix/index.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"glMatrix\": () => (/* reexport safe */ _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"vec3\": () => (/* reexport safe */ _vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gl-matrix */ \"./src/resources/glMatrix/gl-matrix.ts\");\n/* harmony import */ var _vec3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vec3 */ \"./src/resources/glMatrix/vec3.ts\");\n\r\n\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/resources/glMatrix/index.ts?");

/***/ }),

/***/ "./src/resources/glMatrix/vec3.ts":
/*!****************************************!*\
  !*** ./src/resources/glMatrix/vec3.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gl-matrix */ \"./src/resources/glMatrix/gl-matrix.ts\");\n\r\nclass Vec3 {\r\n    constructor() {\r\n        /**\r\n         * Alias for {@link vector3.subtract}\r\n         * @function\r\n         */\r\n        this.sub = this.subtract;\r\n        /**\r\n         * Alias for {@link vector3.multiply}\r\n         * @function\r\n         */\r\n        this.mul = this.multiply;\r\n        /**\r\n         * Alias for {@link vector3.divide}\r\n         * @function\r\n         */\r\n        this.div = this.divide;\r\n        /**\r\n         * Alias for {@link vector3.distance}\r\n         * @function\r\n         */\r\n        this.dist = this.distance;\r\n        /**\r\n         * Alias for {@link vector3.squaredDistance}\r\n         * @function\r\n         */\r\n        this.sqrDist = this.squaredDistance;\r\n        /**\r\n         * Alias for {@link vector3.length}\r\n         * @function\r\n         */\r\n        this.len = this.length;\r\n        /**\r\n         * Alias for {@link vector3.squaredLength}\r\n         * @function\r\n         */\r\n        this.sqrLen = this.squaredLength;\r\n    }\r\n    /**\r\n     * Creates a new, empty vec3\r\n     *\r\n     * @returns {vector3} a new 3D vector\r\n     */\r\n    create() {\r\n        var out = new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        out[0] = 0;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        return out;\r\n    }\r\n    /**\r\n     * Creates a new vec3 initialized with values from an existing vector\r\n     *\r\n     * @param {vector3} a vector to clone\r\n     * @returns {vector3} a new 3D vector\r\n     */\r\n    clone(a) {\r\n        var out = new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        out[0] = a[0];\r\n        out[1] = a[1];\r\n        out[2] = a[2];\r\n        return out;\r\n    }\r\n    /**\r\n     * Creates a new vec3 initialized with the given values\r\n     *\r\n     * @param {Number} x X component\r\n     * @param {Number} y Y component\r\n     * @param {Number} z Z component\r\n     * @returns {vector3} a new 3D vector\r\n     */\r\n    fromValues(x, y, z) {\r\n        var out = new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        out[0] = x;\r\n        out[1] = y;\r\n        out[2] = z;\r\n        return out;\r\n    }\r\n    /**\r\n     * Copy the values from one vec3 to another\r\n     *\r\n     * @param {vector3} out the receiving vector\r\n     * @param {vector3} a the source vector\r\n     * @returns {vector3} out\r\n     */\r\n    copy(a, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        out[0] = a[0];\r\n        out[1] = a[1];\r\n        out[2] = a[2];\r\n        return out;\r\n    }\r\n    /**\r\n     * Set the components of a vec3 to the given values\r\n     *\r\n     * @param {vector3} out the receiving vector\r\n     * @param {Number} x X component\r\n     * @param {Number} y Y component\r\n     * @param {Number} z Z component\r\n     * @returns {vector3} out\r\n     */\r\n    set(x, y, z, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        out[0] = x;\r\n        out[1] = y;\r\n        out[2] = z;\r\n        return out;\r\n    }\r\n    /**\r\n     * Adds two vec3's\r\n     *\r\n     * @param {vector3} a the first operand\r\n     * @param {vector3} b the second operand\r\n     * @param {vector3} out the receiving vector\r\n     * @returns {vector3} out\r\n     */\r\n    add(a, b, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        out[0] = a[0] + b[0];\r\n        out[1] = a[1] + b[1];\r\n        out[2] = a[2] + b[2];\r\n        return out;\r\n    }\r\n    /**\r\n     * Subtracts vector b from vector a\r\n     *\r\n     * @param {vector3} a the first operand\r\n     * @param {vector3} b the second operand\r\n     * @param {vector3} out the receiving vector\r\n     * @returns {vector3} out\r\n     */\r\n    subtract(a, b, out) {\r\n        out = out || new Float32Array(3);\r\n        out[0] = a[0] - b[0];\r\n        out[1] = a[1] - b[1];\r\n        out[2] = a[2] - b[2];\r\n        return out;\r\n    }\r\n    /**\r\n     * Multiplies two vec3's\r\n     *\r\n     * @param {vector3} out the receiving vector\r\n     * @param {vector3} a the first operand\r\n     * @param {vector3} b the second operand\r\n     * @returns {vector3} out\r\n     */\r\n    multiply(a, b, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        out[0] = a[0] * b[0];\r\n        out[1] = a[1] * b[1];\r\n        out[2] = a[2] * b[2];\r\n        return out;\r\n    }\r\n    /**\r\n     * Divides two vec3's\r\n     *\r\n     * @param {vector3} out the receiving vector\r\n     * @param {vector3} a the first operand\r\n     * @param {vector3} b the second operand\r\n     * @returns {vector3} out\r\n     */\r\n    divide(a, b, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        out[0] = a[0] / b[0];\r\n        out[1] = a[1] / b[1];\r\n        out[2] = a[2] / b[2];\r\n        return out;\r\n    }\r\n    /**\r\n     * Returns the minimum of two vec3's\r\n     *\r\n     * @param {vector3} out the receiving vector\r\n     * @param {vector3} a the first operand\r\n     * @param {vector3} b the second operand\r\n     * @returns {vector3} out\r\n     */\r\n    min(a, b, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        out[0] = Math.min(a[0], b[0]);\r\n        out[1] = Math.min(a[1], b[1]);\r\n        out[2] = Math.min(a[2], b[2]);\r\n        return out;\r\n    }\r\n    /**\r\n     * Returns the maximum of two vec3's\r\n     *\r\n     * @param {vector3} out the receiving vector\r\n     * @param {vector3} a the first operand\r\n     * @param {vector3} b the second operand\r\n     * @returns {vector3} out\r\n     */\r\n    max(a, b, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        out[0] = Math.max(a[0], b[0]);\r\n        out[1] = Math.max(a[1], b[1]);\r\n        out[2] = Math.max(a[2], b[2]);\r\n        return out;\r\n    }\r\n    /**\r\n     * Scales a vec3 by a scalar number\r\n     *\r\n     * @param {vector3} out the receiving vector\r\n     * @param {vector3} a the vector to scale\r\n     * @param {Number} b amount to scale the vector by\r\n     * @returns {vector3} out\r\n     */\r\n    scale(a, b, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        out[0] = a[0] * b;\r\n        out[1] = a[1] * b;\r\n        out[2] = a[2] * b;\r\n        return out;\r\n    }\r\n    /**\r\n     * Adds two vec3's after scaling the second operand by a scalar value\r\n     *\r\n     * @param {vector3} out the receiving vector\r\n     * @param {vector3} a the first operand\r\n     * @param {vector3} b the second operand\r\n     * @param {Number} scale the amount to scale b by before adding\r\n     * @returns {vector3} out\r\n     */\r\n    scaleAndAdd(a, b, scale, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        out[0] = a[0] + b[0] * scale;\r\n        out[1] = a[1] + b[1] * scale;\r\n        out[2] = a[2] + b[2] * scale;\r\n        return out;\r\n    }\r\n    /**\r\n     * Calculates the euclidian distance between two vec3's\r\n     *\r\n     * @param {vector3} a the first operand\r\n     * @param {vector3} b the second operand\r\n     * @returns {Number} distance between a and b\r\n     */\r\n    distance(a, b) {\r\n        var x = b[0] - a[0], y = b[1] - a[1], z = b[2] - a[2];\r\n        return Math.sqrt(x * x + y * y + z * z);\r\n    }\r\n    /**\r\n     * Calculates the squared euclidian distance between two vec3's\r\n     *\r\n     * @param {vector3} a the first operand\r\n     * @param {vector3} b the second operand\r\n     * @returns {Number} squared distance between a and b\r\n     */\r\n    squaredDistance(a, b) {\r\n        var x = b[0] - a[0], y = b[1] - a[1], z = b[2] - a[2];\r\n        return x * x + y * y + z * z;\r\n    }\r\n    /**\r\n     * Calculates the length of a vec3\r\n     *\r\n     * @param {vector3} a vector to calculate length of\r\n     * @returns {Number} length of a\r\n     */\r\n    length(a) {\r\n        var x = a[0], y = a[1], z = a[2];\r\n        return Math.sqrt(x * x + y * y + z * z);\r\n    }\r\n    /**\r\n     * Calculates the squared length of a vec3\r\n     *\r\n     * @param {vector3} a vector to calculate squared length of\r\n     * @returns {Number} squared length of a\r\n     */\r\n    squaredLength(a) {\r\n        var x = a[0], y = a[1], z = a[2];\r\n        return x * x + y * y + z * z;\r\n    }\r\n    /**\r\n     * Negates the components of a vec3\r\n     *\r\n     * @param {vector3} out the receiving vector\r\n     * @param {vector3} a vector to negate\r\n     * @returns {vector3} out\r\n     */\r\n    negate(a, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        out[0] = -a[0];\r\n        out[1] = -a[1];\r\n        out[2] = -a[2];\r\n        return out;\r\n    }\r\n    /**\r\n     * Returns the inverse of the components of a vec3\r\n     *\r\n     * @param {vector3} out the receiving vector\r\n     * @param {vector3} a vector to invert\r\n     * @returns {vector3} out\r\n     */\r\n    inverse(a, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        out[0] = 1.0 / a[0];\r\n        out[1] = 1.0 / a[1];\r\n        out[2] = 1.0 / a[2];\r\n        return out;\r\n    }\r\n    /**\r\n     * Normalize a vec3\r\n     *\r\n     * @param {vector3} out the receiving vector\r\n     * @param {vector3} a vector to normalize\r\n     * @returns {vector3} out\r\n     */\r\n    normalize(a, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        var x = a[0], y = a[1], z = a[2];\r\n        var len = x * x + y * y + z * z;\r\n        if (len > 0) {\r\n            //TODO: evaluate use of glm_invsqrt here?\r\n            len = 1 / Math.sqrt(len);\r\n            out[0] = a[0] * len;\r\n            out[1] = a[1] * len;\r\n            out[2] = a[2] * len;\r\n        }\r\n        return out;\r\n    }\r\n    /**\r\n     * Calculates the dot product of two vec3's\r\n     *\r\n     * @param {vector3} a the first operand\r\n     * @param {vector3} b the second operand\r\n     * @returns {Number} dot product of a and b\r\n     */\r\n    dot(a, b) {\r\n        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\r\n    }\r\n    /**\r\n     * Computes the cross product of two vec3's\r\n     *\r\n     * @param {vector3} out the receiving vector\r\n     * @param {vector3} a the first operand\r\n     * @param {vector3} b the second operand\r\n     * @returns {vector3} out\r\n     */\r\n    cross(a, b, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2];\r\n        out[0] = ay * bz - az * by;\r\n        out[1] = az * bx - ax * bz;\r\n        out[2] = ax * by - ay * bx;\r\n        return out;\r\n    }\r\n    /**\r\n     * Performs a linear interpolation between two vec3's\r\n     *\r\n     * @param {vector3} out the receiving vector\r\n     * @param {vector3} a the first operand\r\n     * @param {vector3} b the second operand\r\n     * @param {Number} t interpolation amount between the two inputs\r\n     * @returns {vector3} out\r\n     */\r\n    lerp(a, b, t, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        var ax = a[0], ay = a[1], az = a[2];\r\n        out[0] = ax + t * (b[0] - ax);\r\n        out[1] = ay + t * (b[1] - ay);\r\n        out[2] = az + t * (b[2] - az);\r\n        return out;\r\n    }\r\n    /**\r\n     * Performs a hermite interpolation with two control points\r\n     *\r\n     * @param {vector3} out the receiving vector\r\n     * @param {vector3} a the first operand\r\n     * @param {vector3} b the second operand\r\n     * @param {vector3} c the third operand\r\n     * @param {vector3} d the fourth operand\r\n     * @param {Number} t interpolation amount between the two inputs\r\n     * @returns {vector3} out\r\n     */\r\n    hermite(a, b, c, d, t, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        var factorTimes2 = t * t, factor1 = factorTimes2 * (2 * t - 3) + 1, factor2 = factorTimes2 * (t - 2) + t, factor3 = factorTimes2 * (t - 1), factor4 = factorTimes2 * (3 - 2 * t);\r\n        out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\r\n        out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\r\n        out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\r\n        return out;\r\n    }\r\n    /**\r\n     * Performs a bezier interpolation with two control points\r\n     *\r\n     * @param {vector3} out the receiving vector\r\n     * @param {vector3} a the first operand\r\n     * @param {vector3} b the second operand\r\n     * @param {vector3} c the third operand\r\n     * @param {vector3} d the fourth operand\r\n     * @param {Number} t interpolation amount between the two inputs\r\n     * @returns {vector3} out\r\n     */\r\n    bezier(a, b, c, d, t, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        var inverseFactor = 1 - t, inverseFactorTimesTwo = inverseFactor * inverseFactor, factorTimes2 = t * t, factor1 = inverseFactorTimesTwo * inverseFactor, factor2 = 3 * t * inverseFactorTimesTwo, factor3 = 3 * factorTimes2 * inverseFactor, factor4 = factorTimes2 * t;\r\n        out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\r\n        out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\r\n        out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\r\n        return out;\r\n    }\r\n    /**\r\n     * Generates a random vector with the given scale\r\n     *\r\n     * @param {vector3} out the receiving vector\r\n     * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n     * @returns {vector3} out\r\n     */\r\n    random(scale, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        scale = scale || 1.0;\r\n        var r = _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].RANDOM() * 2.0 * Math.PI;\r\n        var z = _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].RANDOM() * 2.0 - 1.0;\r\n        var zScale = Math.sqrt(1.0 - z * z) * scale;\r\n        out[0] = Math.cos(r) * zScale;\r\n        out[1] = Math.sin(r) * zScale;\r\n        out[2] = z * scale;\r\n        return out;\r\n    }\r\n    /**\r\n     * Transforms the vec3 with a mat4.\r\n     * 4th vector component is implicitly '1'\r\n     *\r\n     * @param {vector3} out the receiving vector\r\n     * @param {vector3} a the vector to transform\r\n     * @param {mat4} m matrix to transform with\r\n     * @returns {vector3} out\r\n     */\r\n    transformMat4(a, m, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        var x = a[0], y = a[1], z = a[2], w = m[3] * x + m[7] * y + m[11] * z + m[15];\r\n        w = w || 1.0;\r\n        out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\r\n        out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\r\n        out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\r\n        return out;\r\n    }\r\n    transformDirection(a, m, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        var x = a[0], y = a[1], z = a[2];\r\n        out[0] = m[0] * x + m[4] * y + m[8] * z;\r\n        out[1] = m[1] * x + m[5] * y + m[9] * z;\r\n        out[2] = m[2] * x + m[6] * y + m[10] * z;\r\n        return out;\r\n    }\r\n    /**\r\n     * Transforms the vec3 with a mat3.\r\n     *\r\n     * @param {vector3} out the receiving vector\r\n     * @param {vector3} a the vector to transform\r\n     * @param {mat4} m the 3x3 matrix to transform with\r\n     * @returns {vector3} out\r\n     */\r\n    transformMat3(a, m, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        var x = a[0], y = a[1], z = a[2];\r\n        out[0] = x * m[0] + y * m[3] + z * m[6];\r\n        out[1] = x * m[1] + y * m[4] + z * m[7];\r\n        out[2] = x * m[2] + y * m[5] + z * m[8];\r\n        return out;\r\n    }\r\n    /**\r\n     * Transforms the vec3 with a quat\r\n     *\r\n     * @param {vector3} out the receiving vector\r\n     * @param {vector3} a the vector to transform\r\n     * @param {quat} q quaternion to transform with\r\n     * @returns {vector3} out\r\n     */\r\n    transformQuat(a, q, out) {\r\n        // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        var x = a[0], y = a[1], z = a[2], qx = q[0], qy = q[1], qz = q[2], qw = q[3], \r\n        // calculate quat * vec\r\n        ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;\r\n        // calculate result * inverse quat\r\n        out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n        out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n        out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n        return out;\r\n    }\r\n    /**\r\n     * Rotate a 3D vector around the x-axis\r\n     * @param {vector3} out The receiving vec3\r\n     * @param {vector3} a The vec3 point to rotate\r\n     * @param {vector3} b The origin of the rotation\r\n     * @param {Number} c The angle of rotation\r\n     * @returns {vector3} out\r\n     */\r\n    rotateX(a, b, c, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        var p = [], r = [];\r\n        //Translate point to the origin\r\n        p[0] = a[0] - b[0];\r\n        p[1] = a[1] - b[1];\r\n        p[2] = a[2] - b[2];\r\n        //perform rotation\r\n        r[0] = p[0];\r\n        r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);\r\n        r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);\r\n        //translate to correct position\r\n        out[0] = r[0] + b[0];\r\n        out[1] = r[1] + b[1];\r\n        out[2] = r[2] + b[2];\r\n        return out;\r\n    }\r\n    /**\r\n     * Rotate a 3D vector around the y-axis\r\n     * @param {vector3} out The receiving vec3\r\n     * @param {vector3} a The vec3 point to rotate\r\n     * @param {vector3} b The origin of the rotation\r\n     * @param {Number} c The angle of rotation\r\n     * @returns {vector3} out\r\n     */\r\n    rotateY(a, b, c, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        var p = [], r = [];\r\n        //Translate point to the origin\r\n        p[0] = a[0] - b[0];\r\n        p[1] = a[1] - b[1];\r\n        p[2] = a[2] - b[2];\r\n        //perform rotation\r\n        r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);\r\n        r[1] = p[1];\r\n        r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);\r\n        //translate to correct position\r\n        out[0] = r[0] + b[0];\r\n        out[1] = r[1] + b[1];\r\n        out[2] = r[2] + b[2];\r\n        return out;\r\n    }\r\n    /**\r\n     * Rotate a 3D vector around the z-axis\r\n     * @param {vector3} out The receiving vec3\r\n     * @param {vector3} a The vec3 point to rotate\r\n     * @param {vector3} b The origin of the rotation\r\n     * @param {Number} c The angle of rotation\r\n     * @returns {vector3} out\r\n     */\r\n    rotateZ(a, b, c, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        var p = [], r = [];\r\n        //Translate point to the origin\r\n        p[0] = a[0] - b[0];\r\n        p[1] = a[1] - b[1];\r\n        p[2] = a[2] - b[2];\r\n        //perform rotation\r\n        r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);\r\n        r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);\r\n        r[2] = p[2];\r\n        //translate to correct position\r\n        out[0] = r[0] + b[0];\r\n        out[1] = r[1] + b[1];\r\n        out[2] = r[2] + b[2];\r\n        return out;\r\n    }\r\n    rotateAxisZ(a, b, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        out[0] = a[0] * Math.cos(b) - a[1] * Math.sin(b);\r\n        out[1] = a[0] * Math.sin(b) + a[1] * Math.cos(b);\r\n        out[2] = a[2];\r\n        return out;\r\n    }\r\n    /**\r\n     * @description 绕任意轴渲染\r\n     * @param out 旋转后的点\r\n     * @param originVector 起始点\r\n     * @param axisVector 旋转轴\r\n     * @param theta 旋转角度\r\n     * @returns {vector3}\r\n     */\r\n    rotateByVector(originVector, axisVector, theta, out) {\r\n        out = out || new _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ARRAY_TYPE(3);\r\n        const c = Math.cos(theta);\r\n        const s = Math.sin(theta);\r\n        out[0] =\r\n            (axisVector[0] * axisVector[0] * (1 - c) + c) * originVector[0] +\r\n                (axisVector[0] * axisVector[1] * (1 - c) - axisVector[2] * s) * originVector[1] +\r\n                (axisVector[0] * axisVector[2] * (1 - c) + axisVector[1] * s) * originVector[2];\r\n        out[1] =\r\n            (axisVector[1] * axisVector[0] * (1 - c) + axisVector[2] * s) * originVector[0] +\r\n                (axisVector[1] * axisVector[1] * (1 - c) + c) * originVector[1] +\r\n                (axisVector[1] * axisVector[2] * (1 - c) - axisVector[0] * s) * originVector[2];\r\n        out[2] =\r\n            (axisVector[0] * axisVector[2] * (1 - c) - axisVector[1] * s) * originVector[0] +\r\n                (axisVector[1] * axisVector[2] * (1 - c) + axisVector[0] * s) * originVector[1] +\r\n                (axisVector[2] * axisVector[2] * (1 - c) + c) * originVector[2];\r\n        return out;\r\n    }\r\n    /**\r\n     * Perform some operation over an array of vec3s.\r\n     *\r\n     * @param {vector3} a the array of vectors to iterate over\r\n     * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\r\n     * @param {Number} offset Number of elements to skip at the beginning of the array\r\n     * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\r\n     * @param {Function} fn Function to call for each vector in the array\r\n     * @param {Object} [arg] additional argument to pass to fn\r\n     * @returns {vector3} a\r\n     * @function\r\n     */\r\n    forEach(a, stride, offset, count, fn, arg) {\r\n        var vec = this.create();\r\n        var i, l;\r\n        if (!stride) {\r\n            stride = 3;\r\n        }\r\n        if (!offset) {\r\n            offset = 0;\r\n        }\r\n        if (count) {\r\n            l = Math.min(count * stride + offset, a.length);\r\n        }\r\n        else {\r\n            l = a.length;\r\n        }\r\n        for (i = offset; i < l; i += stride) {\r\n            vec[0] = a[i];\r\n            vec[1] = a[i + 1];\r\n            vec[2] = a[i + 2];\r\n            fn(vec, vec, arg);\r\n            a[i] = vec[0];\r\n            a[i + 1] = vec[1];\r\n            a[i + 2] = vec[2];\r\n        }\r\n        return a;\r\n    }\r\n    /**\r\n     * Get the angle between two 3D vectors\r\n     * @param {vector3} a The first operand\r\n     * @param {vector3} b The second operand\r\n     * @returns {Number} The angle in radians\r\n     */\r\n    angle(a, b) {\r\n        var tempA = this.fromValues(a[0], a[1], a[2]);\r\n        var tempB = this.fromValues(b[0], b[1], b[2]);\r\n        this.normalize(tempA, tempA);\r\n        this.normalize(tempB, tempB);\r\n        var cosine = this.dot(tempA, tempB);\r\n        if (cosine > 1.0) {\r\n            return 0;\r\n        }\r\n        else if (cosine < -1.0) {\r\n            return Math.PI;\r\n        }\r\n        {\r\n            return Math.acos(cosine);\r\n        }\r\n    }\r\n    angleTo(a, b) {\r\n        let vertical = this.create();\r\n        this.cross(vertical, a, b);\r\n        var tempA = this.fromValues(a[0], a[1], a[2]);\r\n        var tempB = this.fromValues(b[0], b[1], b[2]);\r\n        this.normalize(tempA, tempA);\r\n        this.normalize(tempB, tempB);\r\n        var cosine = this.dot(tempA, tempB);\r\n        if (cosine > 1.0) {\r\n            return 0;\r\n        }\r\n        else if (cosine < -1.0) {\r\n            return Math.PI;\r\n        }\r\n        {\r\n            return vertical[2] > 0 ? Math.acos(cosine) : -Math.acos(cosine);\r\n        }\r\n    }\r\n    /**\r\n     * Returns a string representation of a vector\r\n     *\r\n     * @param {vector3} vec vector to represent as a string\r\n     * @returns {String} string representation of the vector\r\n     */\r\n    str(a) {\r\n        return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\r\n    }\r\n    clamp(value, min, max) {\r\n        return Math.max(min, Math.min(max, value));\r\n    }\r\n}\r\nconst vec3 = new Vec3();\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (vec3);\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/resources/glMatrix/vec3.ts?");

/***/ }),

/***/ "./src/resources/glm.ts":
/*!******************************!*\
  !*** ./src/resources/glm.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\r\n * Makes an identity matrix.\r\n * @param {Matrix4} [dst] optional matrix to store result\r\n * @return {Matrix4} dst or a new matrix if none provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction identity(dst) {\r\n    dst = dst || new Float32Array(16);\r\n    dst[0] = 1;\r\n    dst[1] = 0;\r\n    dst[2] = 0;\r\n    dst[3] = 0;\r\n    dst[4] = 0;\r\n    dst[5] = 1;\r\n    dst[6] = 0;\r\n    dst[7] = 0;\r\n    dst[8] = 0;\r\n    dst[9] = 0;\r\n    dst[10] = 1;\r\n    dst[11] = 0;\r\n    dst[12] = 0;\r\n    dst[13] = 0;\r\n    dst[14] = 0;\r\n    dst[15] = 1;\r\n    return dst;\r\n}\r\n/**\r\n * Makes a translation matrix\r\n * @param {number} tx x translation.\r\n * @param {number} ty y translation.\r\n * @param {number} tz z translation.\r\n * @param {Matrix4} [dst] optional matrix to store result\r\n * @return {Matrix4} dst or a new matrix if none provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction translation(tx, ty, tz, dst) {\r\n    dst = dst || new Float32Array(16);\r\n    dst[0] = 1;\r\n    dst[1] = 0;\r\n    dst[2] = 0;\r\n    dst[3] = 0;\r\n    dst[4] = 0;\r\n    dst[5] = 1;\r\n    dst[6] = 0;\r\n    dst[7] = 0;\r\n    dst[8] = 0;\r\n    dst[9] = 0;\r\n    dst[10] = 1;\r\n    dst[11] = 0;\r\n    dst[12] = tx;\r\n    dst[13] = ty;\r\n    dst[14] = tz;\r\n    dst[15] = 1;\r\n    return dst;\r\n}\r\n/**\r\n * Mutliply by translation matrix.\r\n * @param {Matrix4} m matrix to multiply\r\n * @param {number} tx x translation.\r\n * @param {number} ty y translation.\r\n * @param {number} tz z translation.\r\n * @param {Matrix4} [dst] optional matrix to store result\r\n * @return {Matrix4} dst or a new matrix if none provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction translate(m, tx, ty, tz, dst) {\r\n    // This is the optimized version of\r\n    // return multiply(m, translation(tx, ty, tz), dst);\r\n    dst = dst || new Float32Array(16);\r\n    if (typeof tx != 'number') {\r\n        ty = tx[1];\r\n        tz = tx[2];\r\n        tx = tx[0];\r\n    }\r\n    var m00 = m[0];\r\n    var m01 = m[1];\r\n    var m02 = m[2];\r\n    var m03 = m[3];\r\n    var m10 = m[1 * 4 + 0];\r\n    var m11 = m[1 * 4 + 1];\r\n    var m12 = m[1 * 4 + 2];\r\n    var m13 = m[1 * 4 + 3];\r\n    var m20 = m[2 * 4 + 0];\r\n    var m21 = m[2 * 4 + 1];\r\n    var m22 = m[2 * 4 + 2];\r\n    var m23 = m[2 * 4 + 3];\r\n    var m30 = m[3 * 4 + 0];\r\n    var m31 = m[3 * 4 + 1];\r\n    var m32 = m[3 * 4 + 2];\r\n    var m33 = m[3 * 4 + 3];\r\n    if (m !== dst) {\r\n        dst[0] = m00;\r\n        dst[1] = m01;\r\n        dst[2] = m02;\r\n        dst[3] = m03;\r\n        dst[4] = m10;\r\n        dst[5] = m11;\r\n        dst[6] = m12;\r\n        dst[7] = m13;\r\n        dst[8] = m20;\r\n        dst[9] = m21;\r\n        dst[10] = m22;\r\n        dst[11] = m23;\r\n    }\r\n    dst[12] = m00 * tx + m10 * ty + m20 * tz + m30;\r\n    dst[13] = m01 * tx + m11 * ty + m21 * tz + m31;\r\n    dst[14] = m02 * tx + m12 * ty + m22 * tz + m32;\r\n    dst[15] = m03 * tx + m13 * ty + m23 * tz + m33;\r\n    return dst;\r\n}\r\n/**\r\n * Takes a  matrix and a vector with 4 entries, transforms that vector by\r\n * the matrix, and returns the result as a vector with 4 entries.\r\n * @param {Matrix4} m The matrix.\r\n * @param {Vector4} v The point in homogenous coordinates.\r\n * @param {Vector4} dst optional vector4 to store result\r\n * @return {Vector4} dst or new Vector4 if not provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction transformVector(m, v, dst) {\r\n    dst = dst || new Float32Array(4);\r\n    for (var i = 0; i < 4; ++i) {\r\n        dst[i] = 0.0;\r\n        for (var j = 0; j < 4; ++j) {\r\n            dst[i] += v[j] * m[j * 4 + i];\r\n        }\r\n    }\r\n    return dst;\r\n}\r\n/**\r\n * Takes a 4-by-4 matrix and a vector with 3 entries,\r\n * interprets the vector as a point, transforms that point by the matrix, and\r\n * returns the result as a vector with 3 entries.\r\n * @param {Matrix4} m The matrix.\r\n * @param {Vector3} v The point.\r\n * @param {Vector4} dst optional vector4 to store result\r\n * @return {Vector4} dst or new Vector4 if not provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction transformPoint(m, v, dst) {\r\n    dst = dst || new Float32Array(3);\r\n    var v0 = v[0];\r\n    var v1 = v[1];\r\n    var v2 = v[2];\r\n    var d = v0 * m[0 * 4 + 3] + v1 * m[1 * 4 + 3] + v2 * m[2 * 4 + 3] + m[3 * 4 + 3];\r\n    dst[0] = (v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0] + m[3 * 4 + 0]) / d;\r\n    dst[1] = (v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1] + m[3 * 4 + 1]) / d;\r\n    dst[2] = (v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2] + m[3 * 4 + 2]) / d;\r\n    return dst;\r\n}\r\n/**\r\n * Takes a 4-by-4 matrix and a vector with 3 entries, interprets the vector as a\r\n * direction, transforms that direction by the matrix, and returns the result;\r\n * assumes the transformation of 3-dimensional space represented by the matrix\r\n * is parallel-preserving, i.e. any combination of rotation, scaling and\r\n * translation, but not a perspective distortion. Returns a vector with 3\r\n * entries.\r\n * @param {Matrix4} m The matrix.\r\n * @param {Vector3} v The direction.\r\n * @param {Vector4} dst optional vector4 to store result\r\n * @return {Vector4} dst or new Vector4 if not provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction transformDirection(m, v, dst) {\r\n    dst = dst || new Float32Array(3);\r\n    var v0 = v[0];\r\n    var v1 = v[1];\r\n    var v2 = v[2];\r\n    dst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];\r\n    dst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];\r\n    dst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];\r\n    return dst;\r\n}\r\n/**\r\n * Computes a 4-by-4 perspective transformation matrix given the angular height\r\n * of the frustum, the aspect ratio, and the near and far clipping planes.  The\r\n * arguments define a frustum extending in the negative z direction.  The given\r\n * angle is the vertical angle of the frustum, and the horizontal angle is\r\n * determined to produce the given aspect ratio.  The arguments near and far are\r\n * the distances to the near and far clipping planes.  Note that near and far\r\n * are not z coordinates, but rather they are distances along the negative\r\n * z-axis.  The matrix generated sends the viewing frustum to the unit box.\r\n * We assume a unit box extending from -1 to 1 in the x and y dimensions and\r\n * from -1 to 1 in the z dimension.\r\n * @param {number} fieldOfViewInRadians field of view in y axis.\r\n * @param {number} aspect aspect of viewport (width / height)\r\n * @param {number} near near Z clipping plane\r\n * @param {number} far far Z clipping plane\r\n * @param {Matrix4} [dst] optional matrix to store result\r\n * @return {Matrix4} dst or a new matrix if none provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction perspective(fieldOfViewInRadians, aspect, near, far, dst) {\r\n    dst = dst || new Float32Array(16);\r\n    var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);\r\n    var rangeInv = 1.0 / (near - far);\r\n    dst[0] = f / aspect;\r\n    dst[1] = 0;\r\n    dst[2] = 0;\r\n    dst[3] = 0;\r\n    dst[4] = 0;\r\n    dst[5] = f;\r\n    dst[6] = 0;\r\n    dst[7] = 0;\r\n    dst[8] = 0;\r\n    dst[9] = 0;\r\n    dst[10] = (near + far) * rangeInv;\r\n    dst[11] = -1;\r\n    dst[12] = 0;\r\n    dst[13] = 0;\r\n    dst[14] = near * far * rangeInv * 2;\r\n    dst[15] = 0;\r\n    return dst;\r\n}\r\n/**\r\n * normalizes a vector.\r\n * @param {Vector3} v vector to normalzie\r\n * @param {Vector3} dst optional vector3 to store result\r\n * @return {Vector3} dst or new Vector3 if not provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction normalize(v, dst) {\r\n    dst = dst || new Float32Array(3);\r\n    var length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\r\n    // make sure we don't divide by 0.\r\n    if (length > 0.00001) {\r\n        dst[0] = v[0] / length;\r\n        dst[1] = v[1] / length;\r\n        dst[2] = v[2] / length;\r\n    }\r\n    return dst;\r\n}\r\n/**\r\n * subtracts 2 vectors3s\r\n * @param {Vector3} a a\r\n * @param {Vector3} b b\r\n * @param {Vector3} dst optional vector3 to store result\r\n * @return {Vector3} dst or new Vector3 if not provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction subtractVectors(a, b, dst) {\r\n    dst = dst || new Float32Array(3);\r\n    dst[0] = a[0] - b[0];\r\n    dst[1] = a[1] - b[1];\r\n    dst[2] = a[2] - b[2];\r\n    return dst;\r\n}\r\n/**\r\n * Computes the cross product of 2 vectors3s\r\n * @param {Vector3} a a\r\n * @param {Vector3} b b\r\n * @param {Vector3} dst optional vector3 to store result\r\n * @return {Vector3} dst or new Vector3 if not provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction cross(a, b, dst) {\r\n    dst = dst || new Float32Array(3);\r\n    dst[0] = a[1] * b[2] - a[2] * b[1];\r\n    dst[1] = a[2] * b[0] - a[0] * b[2];\r\n    dst[2] = a[0] * b[1] - a[1] * b[0];\r\n    return dst;\r\n}\r\n/**\r\n * Creates a lookAt matrix.\r\n * This is a world matrix for a camera. In other words it will transform\r\n * from the origin to a place and orientation in the world. For a view\r\n * matrix take the inverse of this.\r\n * @param {Vector3} cameraPosition position of the camera\r\n * @param {Vector3} target position of the target\r\n * @param {Vector3} up direction\r\n * @param {Matrix4} [dst] optional matrix to store result\r\n * @return {Matrix4} dst or a new matrix if none provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction lookAt(cameraPosition, target, up, dst) {\r\n    dst = dst || new Float32Array(16);\r\n    var zAxis = normalize(subtractVectors(cameraPosition, target));\r\n    var xAxis = normalize(cross(up, zAxis));\r\n    var yAxis = normalize(cross(zAxis, xAxis));\r\n    dst[0] = xAxis[0];\r\n    dst[1] = xAxis[1];\r\n    dst[2] = xAxis[2];\r\n    dst[3] = 0;\r\n    dst[4] = yAxis[0];\r\n    dst[5] = yAxis[1];\r\n    dst[6] = yAxis[2];\r\n    dst[7] = 0;\r\n    dst[8] = zAxis[0];\r\n    dst[9] = zAxis[1];\r\n    dst[10] = zAxis[2];\r\n    dst[11] = 0;\r\n    dst[12] = cameraPosition[0];\r\n    dst[13] = cameraPosition[1];\r\n    dst[14] = cameraPosition[2];\r\n    dst[15] = 1;\r\n    return dst;\r\n}\r\n/**\r\n * Computes the inverse of a matrix.\r\n * @param {Matrix4} m matrix to compute inverse of\r\n * @param {Matrix4} [dst] optional matrix to store result\r\n * @return {Matrix4} dst or a new matrix if none provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction inverse(m, dst) {\r\n    dst = dst || new Float32Array(16);\r\n    var m00 = m[0 * 4 + 0];\r\n    var m01 = m[0 * 4 + 1];\r\n    var m02 = m[0 * 4 + 2];\r\n    var m03 = m[0 * 4 + 3];\r\n    var m10 = m[1 * 4 + 0];\r\n    var m11 = m[1 * 4 + 1];\r\n    var m12 = m[1 * 4 + 2];\r\n    var m13 = m[1 * 4 + 3];\r\n    var m20 = m[2 * 4 + 0];\r\n    var m21 = m[2 * 4 + 1];\r\n    var m22 = m[2 * 4 + 2];\r\n    var m23 = m[2 * 4 + 3];\r\n    var m30 = m[3 * 4 + 0];\r\n    var m31 = m[3 * 4 + 1];\r\n    var m32 = m[3 * 4 + 2];\r\n    var m33 = m[3 * 4 + 3];\r\n    var tmp_0 = m22 * m33;\r\n    var tmp_1 = m32 * m23;\r\n    var tmp_2 = m12 * m33;\r\n    var tmp_3 = m32 * m13;\r\n    var tmp_4 = m12 * m23;\r\n    var tmp_5 = m22 * m13;\r\n    var tmp_6 = m02 * m33;\r\n    var tmp_7 = m32 * m03;\r\n    var tmp_8 = m02 * m23;\r\n    var tmp_9 = m22 * m03;\r\n    var tmp_10 = m02 * m13;\r\n    var tmp_11 = m12 * m03;\r\n    var tmp_12 = m20 * m31;\r\n    var tmp_13 = m30 * m21;\r\n    var tmp_14 = m10 * m31;\r\n    var tmp_15 = m30 * m11;\r\n    var tmp_16 = m10 * m21;\r\n    var tmp_17 = m20 * m11;\r\n    var tmp_18 = m00 * m31;\r\n    var tmp_19 = m30 * m01;\r\n    var tmp_20 = m00 * m21;\r\n    var tmp_21 = m20 * m01;\r\n    var tmp_22 = m00 * m11;\r\n    var tmp_23 = m10 * m01;\r\n    var t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -\r\n        (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);\r\n    var t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -\r\n        (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);\r\n    var t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -\r\n        (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);\r\n    var t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -\r\n        (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);\r\n    var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\r\n    dst[0] = d * t0;\r\n    dst[1] = d * t1;\r\n    dst[2] = d * t2;\r\n    dst[3] = d * t3;\r\n    dst[4] = d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) -\r\n        (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));\r\n    dst[5] = d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) -\r\n        (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));\r\n    dst[6] = d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) -\r\n        (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));\r\n    dst[7] = d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) -\r\n        (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));\r\n    dst[8] = d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) -\r\n        (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));\r\n    dst[9] = d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) -\r\n        (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));\r\n    dst[10] = d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) -\r\n        (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));\r\n    dst[11] = d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) -\r\n        (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));\r\n    dst[12] = d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) -\r\n        (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));\r\n    dst[13] = d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) -\r\n        (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));\r\n    dst[14] = d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) -\r\n        (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));\r\n    dst[15] = d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) -\r\n        (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));\r\n    return dst;\r\n}\r\n/**\r\n * Takes two 4-by-4 matrices, a and b, and computes the product in the order\r\n * that pre-composes b with a.  In other words, the matrix returned will\r\n * transform by b first and then a.  Note this is subtly different from just\r\n * multiplying the matrices together.  For given a and b, this function returns\r\n * the same object in both row-major and column-major mode.\r\n * @param {Matrix4} a A matrix.\r\n * @param {Matrix4} b A matrix.\r\n * @param {Matrix4} [dst] optional matrix to store result\r\n * @return {Matrix4} dst or a new matrix if none provided\r\n */\r\nfunction multiply(a, b, dst) {\r\n    dst = dst || new Float32Array(16);\r\n    var b00 = b[0 * 4 + 0];\r\n    var b01 = b[0 * 4 + 1];\r\n    var b02 = b[0 * 4 + 2];\r\n    var b03 = b[0 * 4 + 3];\r\n    var b10 = b[1 * 4 + 0];\r\n    var b11 = b[1 * 4 + 1];\r\n    var b12 = b[1 * 4 + 2];\r\n    var b13 = b[1 * 4 + 3];\r\n    var b20 = b[2 * 4 + 0];\r\n    var b21 = b[2 * 4 + 1];\r\n    var b22 = b[2 * 4 + 2];\r\n    var b23 = b[2 * 4 + 3];\r\n    var b30 = b[3 * 4 + 0];\r\n    var b31 = b[3 * 4 + 1];\r\n    var b32 = b[3 * 4 + 2];\r\n    var b33 = b[3 * 4 + 3];\r\n    var a00 = a[0 * 4 + 0];\r\n    var a01 = a[0 * 4 + 1];\r\n    var a02 = a[0 * 4 + 2];\r\n    var a03 = a[0 * 4 + 3];\r\n    var a10 = a[1 * 4 + 0];\r\n    var a11 = a[1 * 4 + 1];\r\n    var a12 = a[1 * 4 + 2];\r\n    var a13 = a[1 * 4 + 3];\r\n    var a20 = a[2 * 4 + 0];\r\n    var a21 = a[2 * 4 + 1];\r\n    var a22 = a[2 * 4 + 2];\r\n    var a23 = a[2 * 4 + 3];\r\n    var a30 = a[3 * 4 + 0];\r\n    var a31 = a[3 * 4 + 1];\r\n    var a32 = a[3 * 4 + 2];\r\n    var a33 = a[3 * 4 + 3];\r\n    dst[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;\r\n    dst[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;\r\n    dst[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;\r\n    dst[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;\r\n    dst[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;\r\n    dst[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;\r\n    dst[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;\r\n    dst[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;\r\n    dst[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;\r\n    dst[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;\r\n    dst[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;\r\n    dst[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;\r\n    dst[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;\r\n    dst[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;\r\n    dst[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;\r\n    dst[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;\r\n    return dst;\r\n}\r\n/**\r\n * Multiply by an x rotation matrix\r\n * @param {Matrix4} m matrix to multiply\r\n * @param {number} angleInRadians amount to rotate\r\n * @param {Matrix4} [dst] optional matrix to store result\r\n * @return {Matrix4} dst or a new matrix if none provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction xRotate(m, angleInRadians, dst) {\r\n    // this is the optimized version of\r\n    // return multiply(m, xRotation(angleInRadians), dst);\r\n    dst = dst || new Float32Array(16);\r\n    var m10 = m[4];\r\n    var m11 = m[5];\r\n    var m12 = m[6];\r\n    var m13 = m[7];\r\n    var m20 = m[8];\r\n    var m21 = m[9];\r\n    var m22 = m[10];\r\n    var m23 = m[11];\r\n    var c = Math.cos(angleInRadians);\r\n    var s = Math.sin(angleInRadians);\r\n    dst[4] = c * m10 + s * m20;\r\n    dst[5] = c * m11 + s * m21;\r\n    dst[6] = c * m12 + s * m22;\r\n    dst[7] = c * m13 + s * m23;\r\n    dst[8] = c * m20 - s * m10;\r\n    dst[9] = c * m21 - s * m11;\r\n    dst[10] = c * m22 - s * m12;\r\n    dst[11] = c * m23 - s * m13;\r\n    if (m !== dst) {\r\n        dst[0] = m[0];\r\n        dst[1] = m[1];\r\n        dst[2] = m[2];\r\n        dst[3] = m[3];\r\n        dst[12] = m[12];\r\n        dst[13] = m[13];\r\n        dst[14] = m[14];\r\n        dst[15] = m[15];\r\n    }\r\n    return dst;\r\n}\r\n/**\r\n * Makes an y rotation matrix\r\n * @param {number} angleInRadians amount to rotate\r\n * @param {Matrix4} [dst] optional matrix to store result\r\n * @return {Matrix4} dst or a new matrix if none provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction yRotation(angleInRadians, dst) {\r\n    dst = dst || new Float32Array(16);\r\n    var c = Math.cos(angleInRadians);\r\n    var s = Math.sin(angleInRadians);\r\n    dst[0] = c;\r\n    dst[1] = 0;\r\n    dst[2] = -s;\r\n    dst[3] = 0;\r\n    dst[4] = 0;\r\n    dst[5] = 1;\r\n    dst[6] = 0;\r\n    dst[7] = 0;\r\n    dst[8] = s;\r\n    dst[9] = 0;\r\n    dst[10] = c;\r\n    dst[11] = 0;\r\n    dst[12] = 0;\r\n    dst[13] = 0;\r\n    dst[14] = 0;\r\n    dst[15] = 1;\r\n    return dst;\r\n}\r\n/**\r\n * Multiply by an y rotation matrix\r\n * @param {Matrix4} m matrix to multiply\r\n * @param {number} angleInRadians amount to rotate\r\n * @param {Matrix4} [dst] optional matrix to store result\r\n * @return {Matrix4} dst or a new matrix if none provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction yRotate(m, angleInRadians, dst) {\r\n    // this is the optimized verison of\r\n    // return multiply(m, yRotation(angleInRadians), dst);\r\n    dst = dst || new Float32Array(16);\r\n    var m00 = m[0 * 4 + 0];\r\n    var m01 = m[0 * 4 + 1];\r\n    var m02 = m[0 * 4 + 2];\r\n    var m03 = m[0 * 4 + 3];\r\n    var m20 = m[2 * 4 + 0];\r\n    var m21 = m[2 * 4 + 1];\r\n    var m22 = m[2 * 4 + 2];\r\n    var m23 = m[2 * 4 + 3];\r\n    var c = Math.cos(angleInRadians);\r\n    var s = Math.sin(angleInRadians);\r\n    dst[0] = c * m00 - s * m20;\r\n    dst[1] = c * m01 - s * m21;\r\n    dst[2] = c * m02 - s * m22;\r\n    dst[3] = c * m03 - s * m23;\r\n    dst[8] = c * m20 + s * m00;\r\n    dst[9] = c * m21 + s * m01;\r\n    dst[10] = c * m22 + s * m02;\r\n    dst[11] = c * m23 + s * m03;\r\n    if (m !== dst) {\r\n        dst[4] = m[4];\r\n        dst[5] = m[5];\r\n        dst[6] = m[6];\r\n        dst[7] = m[7];\r\n        dst[12] = m[12];\r\n        dst[13] = m[13];\r\n        dst[14] = m[14];\r\n        dst[15] = m[15];\r\n    }\r\n    return dst;\r\n}\r\n/**\r\n * Multiply by an z rotation matrix\r\n * @param {Matrix4} m matrix to multiply\r\n * @param {number} angleInRadians amount to rotate\r\n * @param {Matrix4} [dst] optional matrix to store result\r\n * @return {Matrix4} dst or a new matrix if none provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction zRotate(m, angleInRadians, dst) {\r\n    // This is the optimized verison of\r\n    // return multiply(m, zRotation(angleInRadians), dst);\r\n    dst = dst || new Float32Array(16);\r\n    var m00 = m[0 * 4 + 0];\r\n    var m01 = m[0 * 4 + 1];\r\n    var m02 = m[0 * 4 + 2];\r\n    var m03 = m[0 * 4 + 3];\r\n    var m10 = m[1 * 4 + 0];\r\n    var m11 = m[1 * 4 + 1];\r\n    var m12 = m[1 * 4 + 2];\r\n    var m13 = m[1 * 4 + 3];\r\n    var c = Math.cos(angleInRadians);\r\n    var s = Math.sin(angleInRadians);\r\n    dst[0] = c * m00 + s * m10;\r\n    dst[1] = c * m01 + s * m11;\r\n    dst[2] = c * m02 + s * m12;\r\n    dst[3] = c * m03 + s * m13;\r\n    dst[4] = c * m10 - s * m00;\r\n    dst[5] = c * m11 - s * m01;\r\n    dst[6] = c * m12 - s * m02;\r\n    dst[7] = c * m13 - s * m03;\r\n    if (m !== dst) {\r\n        dst[8] = m[8];\r\n        dst[9] = m[9];\r\n        dst[10] = m[10];\r\n        dst[11] = m[11];\r\n        dst[12] = m[12];\r\n        dst[13] = m[13];\r\n        dst[14] = m[14];\r\n        dst[15] = m[15];\r\n    }\r\n    return dst;\r\n}\r\n/**\r\n  * Multiply by an axis rotation matrix\r\n  * @param {Matrix4} m matrix to multiply\r\n  * @param {Vector3} axis axis to rotate around\r\n  * @param {number} angleInRadians amount to rotate\r\n  * @param {Matrix4} [dst] optional matrix to store result\r\n  * @return {Matrix4} dst or a new matrix if none provided\r\n  * @memberOf module:webgl-3d-math\r\n  */\r\nfunction axisRotate(m, axis, angleInRadians, dst) {\r\n    // This is the optimized verison of\r\n    // return multiply(m, axisRotation(axis, angleInRadians), dst);\r\n    dst = dst || new Float32Array(16);\r\n    var x = axis[0];\r\n    var y = axis[1];\r\n    var z = axis[2];\r\n    var n = Math.sqrt(x * x + y * y + z * z);\r\n    x /= n;\r\n    y /= n;\r\n    z /= n;\r\n    var xx = x * x;\r\n    var yy = y * y;\r\n    var zz = z * z;\r\n    var c = Math.cos(angleInRadians);\r\n    var s = Math.sin(angleInRadians);\r\n    var oneMinusCosine = 1 - c;\r\n    var r00 = xx + (1 - xx) * c;\r\n    var r01 = x * y * oneMinusCosine + z * s;\r\n    var r02 = x * z * oneMinusCosine - y * s;\r\n    var r10 = x * y * oneMinusCosine - z * s;\r\n    var r11 = yy + (1 - yy) * c;\r\n    var r12 = y * z * oneMinusCosine + x * s;\r\n    var r20 = x * z * oneMinusCosine + y * s;\r\n    var r21 = y * z * oneMinusCosine - x * s;\r\n    var r22 = zz + (1 - zz) * c;\r\n    var m00 = m[0];\r\n    var m01 = m[1];\r\n    var m02 = m[2];\r\n    var m03 = m[3];\r\n    var m10 = m[4];\r\n    var m11 = m[5];\r\n    var m12 = m[6];\r\n    var m13 = m[7];\r\n    var m20 = m[8];\r\n    var m21 = m[9];\r\n    var m22 = m[10];\r\n    var m23 = m[11];\r\n    dst[0] = r00 * m00 + r01 * m10 + r02 * m20;\r\n    dst[1] = r00 * m01 + r01 * m11 + r02 * m21;\r\n    dst[2] = r00 * m02 + r01 * m12 + r02 * m22;\r\n    dst[3] = r00 * m03 + r01 * m13 + r02 * m23;\r\n    dst[4] = r10 * m00 + r11 * m10 + r12 * m20;\r\n    dst[5] = r10 * m01 + r11 * m11 + r12 * m21;\r\n    dst[6] = r10 * m02 + r11 * m12 + r12 * m22;\r\n    dst[7] = r10 * m03 + r11 * m13 + r12 * m23;\r\n    dst[8] = r20 * m00 + r21 * m10 + r22 * m20;\r\n    dst[9] = r20 * m01 + r21 * m11 + r22 * m21;\r\n    dst[10] = r20 * m02 + r21 * m12 + r22 * m22;\r\n    dst[11] = r20 * m03 + r21 * m13 + r22 * m23;\r\n    if (m !== dst) {\r\n        dst[12] = m[12];\r\n        dst[13] = m[13];\r\n        dst[14] = m[14];\r\n        dst[15] = m[15];\r\n    }\r\n    return dst;\r\n}\r\n/**\r\n * Computes a 4-by-4 orthographic projection matrix given the coordinates of the\r\n * planes defining the axis-aligned, box-shaped viewing volume.  The matrix\r\n * generated sends that box to the unit box.  Note that although left and right\r\n * are x coordinates and bottom and top are y coordinates, near and far\r\n * are not z coordinates, but rather they are distances along the negative\r\n * z-axis.  We assume a unit box extending from -1 to 1 in the x and y\r\n * dimensions and from -1 to 1 in the z dimension.\r\n * @param {number} left The x coordinate of the left plane of the box.\r\n * @param {number} right The x coordinate of the right plane of the box.\r\n * @param {number} bottom The y coordinate of the bottom plane of the box.\r\n * @param {number} top The y coordinate of the right plane of the box.\r\n * @param {number} near The negative z coordinate of the near plane of the box.\r\n * @param {number} far The negative z coordinate of the far plane of the box.\r\n * @param {Matrix4} [dst] optional matrix to store result\r\n * @return {Matrix4} dst or a new matrix if none provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction orthographic(left, right, bottom, top, near, far, dst) {\r\n    dst = dst || new Float32Array(16);\r\n    dst[0] = 2 / (right - left);\r\n    dst[1] = 0;\r\n    dst[2] = 0;\r\n    dst[3] = 0;\r\n    dst[4] = 0;\r\n    dst[5] = 2 / (top - bottom);\r\n    dst[6] = 0;\r\n    dst[7] = 0;\r\n    dst[8] = 0;\r\n    dst[9] = 0;\r\n    dst[10] = 2 / (near - far);\r\n    dst[11] = 0;\r\n    dst[12] = (left + right) / (left - right);\r\n    dst[13] = (bottom + top) / (bottom - top);\r\n    dst[14] = (near + far) / (near - far);\r\n    dst[15] = 1;\r\n    return dst;\r\n}\r\n/**\r\n * Multiply by a scaling matrix\r\n * @param {Matrix4} m matrix to multiply\r\n * @param {number} sx x scale.\r\n * @param {number} sy y scale.\r\n * @param {number} sz z scale.\r\n * @param {Matrix4} [dst] optional matrix to store result\r\n * @return {Matrix4} dst or a new matrix if none provided\r\n * @memberOf module:webgl-3d-math\r\n */\r\nfunction scale(m, sx, sy, sz, dst) {\r\n    // This is the optimized verison of\r\n    // return multiply(m, scaling(sx, sy, sz), dst);\r\n    dst = dst || new Float32Array(16);\r\n    dst[0] = sx * m[0 * 4 + 0];\r\n    dst[1] = sx * m[0 * 4 + 1];\r\n    dst[2] = sx * m[0 * 4 + 2];\r\n    dst[3] = sx * m[0 * 4 + 3];\r\n    dst[4] = sy * m[1 * 4 + 0];\r\n    dst[5] = sy * m[1 * 4 + 1];\r\n    dst[6] = sy * m[1 * 4 + 2];\r\n    dst[7] = sy * m[1 * 4 + 3];\r\n    dst[8] = sz * m[2 * 4 + 0];\r\n    dst[9] = sz * m[2 * 4 + 1];\r\n    dst[10] = sz * m[2 * 4 + 2];\r\n    dst[11] = sz * m[2 * 4 + 3];\r\n    if (m !== dst) {\r\n        dst[12] = m[12];\r\n        dst[13] = m[13];\r\n        dst[14] = m[14];\r\n        dst[15] = m[15];\r\n    }\r\n    return dst;\r\n}\r\nfunction radians(angle) {\r\n    return angle * Math.PI / 180;\r\n}\r\nfunction cos(value) {\r\n    return Math.cos(value);\r\n}\r\nfunction add(a, b, dst) {\r\n    dst = dst || new Float32Array(3);\r\n    dst[0] = a[0] + b[0];\r\n    dst[1] = a[1] + b[1];\r\n    dst[2] = a[2] + b[2];\r\n    return dst;\r\n}\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\r\n    identity,\r\n    translation,\r\n    translate,\r\n    transformVector,\r\n    transformPoint,\r\n    transformDirection,\r\n    perspective,\r\n    lookAt,\r\n    inverse,\r\n    multiply,\r\n    xRotate,\r\n    yRotate,\r\n    zRotate,\r\n    axisRotate,\r\n    yRotation,\r\n    orthographic,\r\n    scale,\r\n    radians,\r\n    normalize,\r\n    cross,\r\n    add,\r\n    cos,\r\n});\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/resources/glm.ts?");

/***/ }),

/***/ "./src/resources/webgl-utils.ts":
/*!**************************************!*\
  !*** ./src/resources/webgl-utils.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AugmentTypedArray1\": () => (/* binding */ AugmentTypedArray1),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// export default class webglUtils {\r\n/**\r\n   * Wrapped logging function.\r\n   * @param {string} msg The message to log.\r\n   */\r\nfunction error(msg) {\r\n    // if (this.topWindow.console) {\r\n    //     if (topWindow.console.error) {\r\n    //         topWindow.console.error(msg);\r\n    //     } else if (topWindow.console.log) {\r\n    //         topWindow.console.log(msg);\r\n    //     }\r\n    // }\r\n}\r\n/**\r\n* Resize a canvas to match the size its displayed.\r\n* @param {HTMLCanvasElement} canvas The canvas to resize.\r\n* @param {number} [multiplier] amount to multiply by.\r\n*    Pass in window.devicePixelRatio for native pixels.\r\n* @return {boolean} true if the canvas was resized.\r\n* @memberOf module:webgl-utils\r\n*/\r\nfunction resizeCanvasToDisplaySize(canvas, multiplier) {\r\n    multiplier = multiplier || 1;\r\n    var width = canvas.clientWidth * multiplier | 0;\r\n    var height = canvas.clientHeight * multiplier | 0;\r\n    if (canvas.width !== width || canvas.height !== height) {\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nconst defaultShaderType = [\r\n    \"VERTEX_SHADER\",\r\n    \"FRAGMENT_SHADER\",\r\n];\r\n/**\r\n* Creates a program from 2 script tags.\r\n* @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\r\n* @param {string[]} shaderStrings Array of ids of the script tags for the shaders. The first is assumed to be the\r\nvertex shader, the second the fragment shader.\r\n* @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\r\n* @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\r\n* @param {} opt_errorCallback callback for errors. By default it just prints an error to the console\r\non error. If you want something else pass an callback. It's passed an error message.\r\n* @return {WebGLProgram} The created program.\r\n* @memberOf module:webgl-utils\r\n*/\r\nfunction createProgramFromStrings(gl, shaderStrings, opt_attribs, opt_locations, opt_errorCallback) {\r\n    var shaders = [];\r\n    for (var ii = 0; ii < shaderStrings.length; ++ii) {\r\n        shaders.push(createShaderFromString(gl, shaderStrings[ii], gl[defaultShaderType[ii]], opt_errorCallback));\r\n    }\r\n    return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);\r\n}\r\n/**\r\n* Loads a shader from a script tag.\r\n* @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\r\n* @param {string} shaderString The id of the script tag.\r\n* @param {number} opt_shaderType The type of shader. If not passed in it will\r\nbe derived from the type of the script tag.\r\n* @param {} opt_errorCallback callback for errors.\r\n* @return {WebGLShader} The created shader.\r\n*/\r\nfunction createShaderFromString(gl, shaderString, opt_shaderType, opt_errorCallback) {\r\n    var shaderSource = \"\";\r\n    var shaderType;\r\n    // var shaderScript = document.getElementById(scriptId);\r\n    // if (!shaderScript) {\r\n    //     throw (\"*** Error: unknown script element\" + scriptId);\r\n    // }\r\n    shaderSource = shaderString;\r\n    // if (!opt_shaderType) {\r\n    //     if (shaderScript.type === \"x-shader/x-vertex\") {\r\n    //         shaderType = gl.VERTEX_SHADER;\r\n    //     } else if (shaderScript.type === \"x-shader/x-fragment\") {\r\n    //         shaderType = gl.FRAGMENT_SHADER;\r\n    //     } else if (shaderType !== gl.VERTEX_SHADER && shaderType !== gl.FRAGMENT_SHADER) {\r\n    //         throw (\"*** Error: unknown shader type\");\r\n    //     }\r\n    // }\r\n    return loadShader(gl, shaderSource, opt_shaderType ? opt_shaderType : shaderType, opt_errorCallback);\r\n}\r\n/**\r\n * Loads a shader.\r\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\r\n * @param {string} shaderSource The shader source.\r\n * @param {number} shaderType The type of shader.\r\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors.\r\n * @return {WebGLShader} The created shader.\r\n */\r\nfunction loadShader(gl, shaderSource, shaderType, opt_errorCallback) {\r\n    var errFn = opt_errorCallback || error;\r\n    // Create the shader object\r\n    var shader = gl.createShader(shaderType);\r\n    // Load the shader source\r\n    gl.shaderSource(shader, shaderSource);\r\n    // Compile the shader\r\n    gl.compileShader(shader);\r\n    // Check the compile status\r\n    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    if (!compiled) {\r\n        // Something went wrong during compilation; get the error\r\n        var lastError = gl.getShaderInfoLog(shader);\r\n        console.error(\"*** Error compiling shader '\" + shader + \"':\" + lastError);\r\n        gl.deleteShader(shader);\r\n        return null;\r\n    }\r\n    return shader;\r\n}\r\n/**\r\n* Creates a program, attaches shaders, binds attrib locations, links the\r\n* program and calls useProgram.\r\n* @param {WebGLShader[]} shaders The shaders to attach\r\n* @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\r\n* @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\r\n* @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\r\n*        on error. If you want something else pass an callback. It's passed an error message.\r\n* @memberOf module:webgl-utils\r\n*/\r\nfunction createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {\r\n    var errFn = opt_errorCallback || error;\r\n    var program = gl.createProgram();\r\n    shaders.forEach(function (shader) {\r\n        gl.attachShader(program, shader);\r\n    });\r\n    if (opt_attribs) {\r\n        opt_attribs.forEach(function (attrib, ndx) {\r\n            gl.bindAttribLocation(program, opt_locations ? opt_locations[ndx] : ndx, attrib);\r\n        });\r\n    }\r\n    gl.linkProgram(program);\r\n    // Check the link status\r\n    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n    if (!linked) {\r\n        // something went wrong with the link\r\n        var lastError = gl.getProgramInfoLog(program);\r\n        console.error(\"Error in program linking:\" + lastError);\r\n        gl.deleteProgram(program);\r\n        return null;\r\n    }\r\n    return program;\r\n}\r\n/**\r\n   * Creates a ProgramInfo from 2 sources.\r\n   *\r\n   * A ProgramInfo contains\r\n   *\r\n   *     programInfo = {\r\n   *        program: WebGLProgram,\r\n   *        uniformSetters: object of setters as returned from createUniformSetters,\r\n   *        attribSetters: object of setters as returned from createAttribSetters,\r\n   *     }\r\n   *\r\n   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\r\n   *        to use.\r\n   * @param {string[]} shaderSourcess Array of sources for the\r\n   *        shaders or ids. The first is assumed to be the vertex shader,\r\n   *        the second the fragment shader.\r\n   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\r\n   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\r\n   * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\r\n   *        on error. If you want something else pass an callback. It's passed an error message.\r\n   * @return {module:webgl-utils.ProgramInfo} The created program.\r\n   * @memberOf module:webgl-utils\r\n   */\r\nfunction createProgramInfo(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {\r\n    // shaderSources = shaderSources.map(function (source) {\r\n    //   var script = document.getElementById(source);\r\n    //   return script ? script.text : source;\r\n    // });\r\n    var program = createProgramFromStrings(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback);\r\n    if (!program) {\r\n        return null;\r\n    }\r\n    var uniformSetters = createUniformSetters(gl, program);\r\n    var attribSetters = createAttributeSetters(gl, program);\r\n    let programInfor = {\r\n        program: program,\r\n        uniformSetters: uniformSetters,\r\n        attribSetters: attribSetters\r\n    };\r\n    return programInfor;\r\n}\r\n/**\r\n * Sets attributes and buffers including the `ELEMENT_ARRAY_BUFFER` if appropriate\r\n *\r\n * Example:\r\n *\r\n *     var programInfo = createProgramInfo(\r\n *         gl, [\"some-vs\", \"some-fs\");\r\n *\r\n *     var arrays = {\r\n *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\r\n *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\r\n *     };\r\n *\r\n *     var bufferInfo = createBufferInfoFromArrays(gl, arrays);\r\n *\r\n *     gl.useProgram(programInfo.program);\r\n *\r\n * This will automatically bind the buffers AND set the\r\n * attributes.\r\n *\r\n *     setBuffersAndAttributes(programInfo.attribSetters, bufferInfo);\r\n *\r\n * For the example above it is equivilent to\r\n *\r\n *     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n *     gl.enableVertexAttribArray(a_positionLocation);\r\n *     gl.vertexAttribPointer(a_positionLocation, 3, gl.FLOAT, false, 0, 0);\r\n *     gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\r\n *     gl.enableVertexAttribArray(a_texcoordLocation);\r\n *     gl.vertexAttribPointer(a_texcoordLocation, 4, gl.FLOAT, false, 0, 0);\r\n *\r\n * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\r\n * @param {Object.<string, function>} setters Attribute setters as returned from `createAttributeSetters`\r\n * @param {module:webgl-utils.BufferInfo} buffers a BufferInfo as returned from `createBufferInfoFromArrays`.\r\n * @memberOf module:webgl-utils\r\n */\r\nfunction setBuffersAndAttributes(gl, setters, buffers) {\r\n    setAttributes(setters, buffers.attribs);\r\n    if (buffers.indices) {\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\r\n    }\r\n}\r\n/**\r\n * Set uniforms and binds related textures.\r\n *\r\n * example:\r\n *\r\n *     var programInfo = createProgramInfo(\r\n *         gl, [\"some-vs\", \"some-fs\");\r\n *\r\n *     var tex1 = gl.createTexture();\r\n *     var tex2 = gl.createTexture();\r\n *\r\n *     ... assume we setup the textures with data ...\r\n *\r\n *     var uniforms = {\r\n *       u_someSampler: tex1,\r\n *       u_someOtherSampler: tex2,\r\n *       u_someColor: [1,0,0,1],\r\n *       u_somePosition: [0,1,1],\r\n *       u_someMatrix: [\r\n *         1,0,0,0,\r\n *         0,1,0,0,\r\n *         0,0,1,0,\r\n *         0,0,0,0,\r\n *       ],\r\n *     };\r\n *\r\n *     gl.useProgram(program);\r\n *\r\n * This will automatically bind the textures AND set the\r\n * uniforms.\r\n *\r\n *     setUniforms(programInfo.uniformSetters, uniforms);\r\n *\r\n * For the example above it is equivalent to\r\n *\r\n *     var texUnit = 0;\r\n *     gl.activeTexture(gl.TEXTURE0 + texUnit);\r\n *     gl.bindTexture(gl.TEXTURE_2D, tex1);\r\n *     gl.uniform1i(u_someSamplerLocation, texUnit++);\r\n *     gl.activeTexture(gl.TEXTURE0 + texUnit);\r\n *     gl.bindTexture(gl.TEXTURE_2D, tex2);\r\n *     gl.uniform1i(u_someSamplerLocation, texUnit++);\r\n *     gl.uniform4fv(u_someColorLocation, [1, 0, 0, 1]);\r\n *     gl.uniform3fv(u_somePositionLocation, [0, 1, 1]);\r\n *     gl.uniformMatrix4fv(u_someMatrix, false, [\r\n *         1,0,0,0,\r\n *         0,1,0,0,\r\n *         0,0,1,0,\r\n *         0,0,0,0,\r\n *       ]);\r\n *\r\n * Note it is perfectly reasonable to call `setUniforms` multiple times. For example\r\n *\r\n *     var uniforms = {\r\n *       u_someSampler: tex1,\r\n *       u_someOtherSampler: tex2,\r\n *     };\r\n *\r\n *     var moreUniforms {\r\n *       u_someColor: [1,0,0,1],\r\n *       u_somePosition: [0,1,1],\r\n *       u_someMatrix: [\r\n *         1,0,0,0,\r\n *         0,1,0,0,\r\n *         0,0,1,0,\r\n *         0,0,0,0,\r\n *       ],\r\n *     };\r\n *\r\n *     setUniforms(programInfo.uniformSetters, uniforms);\r\n *     setUniforms(programInfo.uniformSetters, moreUniforms);\r\n *\r\n * @param {Object.<string, function>|module:webgl-utils.ProgramInfo} setters the setters returned from\r\n *        `createUniformSetters` or a ProgramInfo from {@link module:webgl-utils.createProgramInfo}.\r\n * @param {Object.<string, value>} an object with values for the\r\n *        uniforms.\r\n * @memberOf module:webgl-utils\r\n */\r\nfunction setUniforms(setters, values) {\r\n    let mySetters = setters.uniformSetters || setters;\r\n    Object.keys(values).forEach(function (name) {\r\n        var setter = mySetters[name];\r\n        if (setter) {\r\n            setter(values[name]);\r\n        }\r\n    });\r\n}\r\n/**\r\n * Creates setter functions for all attributes of a shader\r\n * program. You can pass this to {@link module:webgl-utils.setBuffersAndAttributes} to set all your buffers and attributes.\r\n *\r\n * @see {@link module:webgl-utils.setAttributes} for example\r\n * @param {WebGLProgram} program the program to create setters for.\r\n * @return {Object.<string, function>} an object with a setter for each attribute by name.\r\n * @memberOf module:webgl-utils\r\n */\r\nfunction createAttributeSetters(gl, program) {\r\n    var attribSetters = {};\r\n    function createAttribSetter(index) {\r\n        return function (b) {\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);\r\n            gl.enableVertexAttribArray(index);\r\n            gl.vertexAttribPointer(index, b.numComponents || b.size, b.type || gl.FLOAT, b.normalize || false, b.stride || 0, b.offset || 0);\r\n        };\r\n    }\r\n    var numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\r\n    for (var ii = 0; ii < numAttribs; ++ii) {\r\n        var attribInfo = gl.getActiveAttrib(program, ii);\r\n        if (!attribInfo) {\r\n            break;\r\n        }\r\n        var index = gl.getAttribLocation(program, attribInfo.name);\r\n        attribSetters[attribInfo.name] = createAttribSetter(index);\r\n    }\r\n    return attribSetters;\r\n}\r\n/**\r\n * Sets attributes and binds buffers (deprecated... use {@link module:webgl-utils.setBuffersAndAttributes})\r\n *\r\n * Example:\r\n *\r\n *     var program = createProgramFromScripts(\r\n *         gl, [\"some-vs\", \"some-fs\");\r\n *\r\n *     var attribSetters = createAttributeSetters(program);\r\n *\r\n *     var positionBuffer = gl.createBuffer();\r\n *     var texcoordBuffer = gl.createBuffer();\r\n *\r\n *     var attribs = {\r\n *       a_position: {buffer: positionBuffer, numComponents: 3},\r\n *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\r\n *     };\r\n *\r\n *     gl.useProgram(program);\r\n *\r\n * This will automatically bind the buffers AND set the\r\n * attributes.\r\n *\r\n *     setAttributes(attribSetters, attribs);\r\n *\r\n * Properties of attribs. For each attrib you can add\r\n * properties:\r\n *\r\n * *   type: the type of data in the buffer. Default = gl.FLOAT\r\n * *   normalize: whether or not to normalize the data. Default = false\r\n * *   stride: the stride. Default = 0\r\n * *   offset: offset into the buffer. Default = 0\r\n *\r\n * For example if you had 3 value float positions, 2 value\r\n * float texcoord and 4 value uint8 colors you'd setup your\r\n * attribs like this\r\n *\r\n *     var attribs = {\r\n *       a_position: {buffer: positionBuffer, numComponents: 3},\r\n *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\r\n *       a_color: {\r\n *         buffer: colorBuffer,\r\n *         numComponents: 4,\r\n *         type: gl.UNSIGNED_BYTE,\r\n *         normalize: true,\r\n *       },\r\n *     };\r\n *\r\n * @param {Object.<string, function>|model:webgl-utils.ProgramInfo} setters Attribute setters as returned from createAttributeSetters or a ProgramInfo as returned {@link module:webgl-utils.createProgramInfo}\r\n * @param {Object.<string, module:webgl-utils.AttribInfo>} attribs AttribInfos mapped by attribute name.\r\n * @memberOf module:webgl-utils\r\n * @deprecated use {@link module:webgl-utils.setBuffersAndAttributes}\r\n */\r\nfunction setAttributes(setters, attribs) {\r\n    let mySetters = setters.attribSetters || setters;\r\n    Object.keys(attribs).forEach(function (name) {\r\n        var setter = mySetters[name];\r\n        if (setter) {\r\n            setter(attribs[name]);\r\n        }\r\n    });\r\n}\r\n/**\r\n   * Creates setter functions for all uniforms of a shader\r\n   * program.\r\n   *\r\n   * @see {@link module:webgl-utils.setUniforms}\r\n   *\r\n   * @param {WebGLProgram} program the program to create setters for.\r\n   * @returns {Object.<string, function>} an object with a setter by name for each uniform\r\n   * @memberOf module:webgl-utils\r\n   */\r\nfunction createUniformSetters(gl, program) {\r\n    var textureUnit = 0;\r\n    /**\r\n     * Creates a setter for a uniform of the given program with it's\r\n     * location embedded in the setter.\r\n     * @param {WebGLProgram} program\r\n     * @param {WebGLUniformInfo} uniformInfo\r\n     * @returns {function} the created setter.\r\n     */\r\n    function createUniformSetter(program, uniformInfo) {\r\n        var location = gl.getUniformLocation(program, uniformInfo.name);\r\n        var type = uniformInfo.type;\r\n        // Check if this uniform is an array\r\n        var isArray = (uniformInfo.size > 1 && uniformInfo.name.substr(-3) === \"[0]\");\r\n        if (type === gl.FLOAT && isArray) {\r\n            return function (v) {\r\n                gl.uniform1fv(location, v);\r\n            };\r\n        }\r\n        if (type === gl.FLOAT) {\r\n            return function (v) {\r\n                gl.uniform1f(location, v);\r\n            };\r\n        }\r\n        if (type === gl.FLOAT_VEC2) {\r\n            return function (v) {\r\n                gl.uniform2fv(location, v);\r\n            };\r\n        }\r\n        if (type === gl.FLOAT_VEC3) {\r\n            return function (v) {\r\n                gl.uniform3fv(location, v);\r\n            };\r\n        }\r\n        if (type === gl.FLOAT_VEC4) {\r\n            return function (v) {\r\n                gl.uniform4fv(location, v);\r\n            };\r\n        }\r\n        if (type === gl.INT && isArray) {\r\n            return function (v) {\r\n                gl.uniform1iv(location, v);\r\n            };\r\n        }\r\n        if (type === gl.INT) {\r\n            return function (v) {\r\n                gl.uniform1i(location, v);\r\n            };\r\n        }\r\n        if (type === gl.INT_VEC2) {\r\n            return function (v) {\r\n                gl.uniform2iv(location, v);\r\n            };\r\n        }\r\n        if (type === gl.INT_VEC3) {\r\n            return function (v) {\r\n                gl.uniform3iv(location, v);\r\n            };\r\n        }\r\n        if (type === gl.INT_VEC4) {\r\n            return function (v) {\r\n                gl.uniform4iv(location, v);\r\n            };\r\n        }\r\n        if (type === gl.BOOL) {\r\n            return function (v) {\r\n                gl.uniform1iv(location, v);\r\n            };\r\n        }\r\n        if (type === gl.BOOL_VEC2) {\r\n            return function (v) {\r\n                gl.uniform2iv(location, v);\r\n            };\r\n        }\r\n        if (type === gl.BOOL_VEC3) {\r\n            return function (v) {\r\n                gl.uniform3iv(location, v);\r\n            };\r\n        }\r\n        if (type === gl.BOOL_VEC4) {\r\n            return function (v) {\r\n                gl.uniform4iv(location, v);\r\n            };\r\n        }\r\n        if (type === gl.FLOAT_MAT2) {\r\n            return function (v) {\r\n                gl.uniformMatrix2fv(location, false, v);\r\n            };\r\n        }\r\n        if (type === gl.FLOAT_MAT3) {\r\n            return function (v) {\r\n                gl.uniformMatrix3fv(location, false, v);\r\n            };\r\n        }\r\n        if (type === gl.FLOAT_MAT4) {\r\n            return function (v) {\r\n                gl.uniformMatrix4fv(location, false, v);\r\n            };\r\n        }\r\n        if ((type === gl.SAMPLER_2D || type === gl.SAMPLER_CUBE) && isArray) {\r\n            var units = [];\r\n            for (var ii = 0; ii < uniformInfo.size; ++ii) {\r\n                units.push(textureUnit++);\r\n            }\r\n            return function (bindPoint, units) {\r\n                return function (textures) {\r\n                    gl.uniform1iv(location, units);\r\n                    textures.forEach(function (texture, index) {\r\n                        gl.activeTexture(gl.TEXTURE0 + units[index]);\r\n                        gl.bindTexture(bindPoint, texture);\r\n                    });\r\n                };\r\n            }(getBindPointForSamplerType(gl, type), units);\r\n        }\r\n        if (type === gl.SAMPLER_2D || type === gl.SAMPLER_CUBE) {\r\n            return function (bindPoint, unit) {\r\n                return function (texture) {\r\n                    gl.uniform1i(location, unit);\r\n                    gl.activeTexture(gl.TEXTURE0 + unit);\r\n                    gl.bindTexture(bindPoint, texture);\r\n                };\r\n            }(getBindPointForSamplerType(gl, type), textureUnit++);\r\n        }\r\n        throw (\"unknown type: 0x\" + type.toString(16)); // we should never get here.\r\n    }\r\n    var uniformSetters = {};\r\n    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\r\n    for (var ii = 0; ii < numUniforms; ++ii) {\r\n        var uniformInfo = gl.getActiveUniform(program, ii);\r\n        if (!uniformInfo) {\r\n            break;\r\n        }\r\n        var name = uniformInfo.name;\r\n        // remove the array suffix.\r\n        if (name.substr(-3) === \"[0]\") {\r\n            name = name.substr(0, name.length - 3);\r\n        }\r\n        var setter = createUniformSetter(program, uniformInfo);\r\n        uniformSetters[name] = setter;\r\n    }\r\n    return uniformSetters;\r\n}\r\n/**\r\n * Returns the corresponding bind point for a given sampler type\r\n */\r\nfunction getBindPointForSamplerType(gl, type) {\r\n    if (type === gl.SAMPLER_2D)\r\n        return gl.TEXTURE_2D; // eslint-disable-line\r\n    if (type === gl.SAMPLER_CUBE)\r\n        return gl.TEXTURE_CUBE_MAP; // eslint-disable-line\r\n    return undefined;\r\n}\r\nfunction allButIndices(name) {\r\n    return name !== \"indices\";\r\n}\r\nfunction createMapping(obj) {\r\n    var mapping = {};\r\n    Object.keys(obj).filter(allButIndices).forEach(function (key) {\r\n        mapping[\"a_\" + key] = key;\r\n    });\r\n    return mapping;\r\n}\r\nfunction getGLTypeForTypedArray(gl, typedArray) {\r\n    if (typedArray instanceof Int8Array) {\r\n        return gl.BYTE;\r\n    } // eslint-disable-line\r\n    if (typedArray instanceof Uint8Array) {\r\n        return gl.UNSIGNED_BYTE;\r\n    } // eslint-disable-line\r\n    if (typedArray instanceof Int16Array) {\r\n        return gl.SHORT;\r\n    } // eslint-disable-line\r\n    if (typedArray instanceof Uint16Array) {\r\n        return gl.UNSIGNED_SHORT;\r\n    } // eslint-disable-line\r\n    if (typedArray instanceof Int32Array) {\r\n        return gl.INT;\r\n    } // eslint-disable-line\r\n    if (typedArray instanceof Uint32Array) {\r\n        return gl.UNSIGNED_INT;\r\n    } // eslint-disable-line\r\n    if (typedArray instanceof Float32Array) {\r\n        return gl.FLOAT;\r\n    } // eslint-disable-line\r\n    throw \"unsupported typed array type\";\r\n}\r\n// This is really just a guess. Though I can't really imagine using\r\n// anything else? Maybe for some compression?\r\nfunction getNormalizationForTypedArray(typedArray) {\r\n    if (typedArray instanceof Int8Array) {\r\n        return true;\r\n    } // eslint-disable-line\r\n    if (typedArray instanceof Uint8Array) {\r\n        return true;\r\n    } // eslint-disable-line\r\n    return false;\r\n}\r\nfunction isArrayBuffer(a) {\r\n    return a.buffer && a.buffer instanceof ArrayBuffer;\r\n}\r\nfunction guessNumComponentsFromName(name, length) {\r\n    var numComponents;\r\n    if (name.indexOf(\"coord\") >= 0) {\r\n        numComponents = 2;\r\n    }\r\n    else if (name.indexOf(\"color\") >= 0) {\r\n        numComponents = 4;\r\n    }\r\n    else {\r\n        numComponents = 3; // position, normals, indices ...\r\n    }\r\n    if (length % numComponents > 0) {\r\n        throw \"can not guess numComponents. You should specify it.\";\r\n    }\r\n    return numComponents;\r\n}\r\n/**\r\n * creates a typed array with a `push` function attached\r\n * so that you can easily *push* values.\r\n *\r\n * `push` can take multiple arguments. If an argument is an array each element\r\n * of the array will be added to the typed array.\r\n *\r\n * Example:\r\n *\r\n *     var array = createAugmentedTypedArray(3, 2);  // creates a Float32Array with 6 values\r\n *     array.push(1, 2, 3);\r\n *     array.push([4, 5, 6]);\r\n *     // array now contains [1, 2, 3, 4, 5, 6]\r\n *\r\n * Also has `numComponents` and `numElements` properties.\r\n *\r\n * @param {number} numComponents number of components\r\n * @param {number} numElements number of elements. The total size of the array will be `numComponents * numElements`.\r\n * @param {constructor} opt_type A constructor for the type. Default = `Float32Array`.\r\n * @return {ArrayBuffer} A typed array.\r\n * @memberOf module:webgl-utils\r\n */\r\nfunction createAugmentedTypedArray(numComponents, numElements, opt_type) {\r\n    var Type = opt_type || Float32Array;\r\n    return augmentTypedArray(new Type(numComponents * numElements), numComponents);\r\n    // return new AugmentTypedArray(numComponents, numElements, opt_type);\r\n}\r\n/**\r\n * tries to get the number of elements from a set of arrays.\r\n */\r\nfunction getNumElementsFromNonIndexedArrays(arrays) {\r\n    var key = Object.keys(arrays)[0];\r\n    var array = arrays[key];\r\n    if (isArrayBuffer(array)) {\r\n        return array.numElements;\r\n    }\r\n    else {\r\n        return array.data.length / array.numComponents;\r\n    }\r\n}\r\nclass AugmentTypedArray1 {\r\n    constructor(numComponents, numElements, opt_type) {\r\n        this.cursor = 0;\r\n        this.numComponents = numComponents;\r\n        var Type = opt_type || Float32Array;\r\n        this.arrayBuffer = new Type(numComponents * numElements);\r\n    }\r\n    push(...arg) {\r\n        for (var ii = 0; ii < arg.length; ++ii) {\r\n            var value = arg[ii];\r\n            if (value instanceof Array || (value.buffer && value.buffer instanceof ArrayBuffer)) {\r\n                for (var jj = 0; jj < value.length; ++jj) {\r\n                    this.arrayBuffer[this.cursor++] = value[jj];\r\n                }\r\n            }\r\n            else {\r\n                this.arrayBuffer[this.cursor++] = value;\r\n            }\r\n        }\r\n    }\r\n    reset(opt_index) {\r\n        this.cursor = opt_index || 0;\r\n    }\r\n    get ArrayBuffer() {\r\n        return this.arrayBuffer;\r\n    }\r\n    get numElements() {\r\n        return this.arrayBuffer.length / this.numComponents | 0;\r\n    }\r\n}\r\n// Add `push` to a typed array. It just keeps a 'cursor'\r\n// and allows use to `push` values into the array so we\r\n// don't have to manually compute offsets\r\nfunction augmentTypedArray(typedArray, numComponents) {\r\n    var cursor = 0;\r\n    typedArray.push = function () {\r\n        for (var ii = 0; ii < arguments.length; ++ii) {\r\n            var value = arguments[ii];\r\n            if (value instanceof Array || (value.buffer && value.buffer instanceof ArrayBuffer)) {\r\n                for (var jj = 0; jj < value.length; ++jj) {\r\n                    typedArray[cursor++] = value[jj];\r\n                }\r\n            }\r\n            else {\r\n                typedArray[cursor++] = value;\r\n            }\r\n        }\r\n    };\r\n    typedArray.reset = function (opt_index) {\r\n        cursor = opt_index || 0;\r\n    };\r\n    typedArray.numComponents = numComponents;\r\n    Object.defineProperty(typedArray, 'numElements', {\r\n        get: function () {\r\n            return this.length / this.numComponents | 0;\r\n        },\r\n    });\r\n    return typedArray;\r\n}\r\nfunction createBufferFromTypedArray(gl, array, type, drawType) {\r\n    type = type || gl.ARRAY_BUFFER;\r\n    var buffer = gl.createBuffer();\r\n    gl.bindBuffer(type, buffer);\r\n    gl.bufferData(type, array, drawType || gl.STATIC_DRAW);\r\n    return buffer;\r\n}\r\nfunction makeTypedArray(array, name) {\r\n    if (isArrayBuffer(array)) {\r\n        return array;\r\n    }\r\n    if (array.data && isArrayBuffer(array.data)) {\r\n        return array.data;\r\n    }\r\n    if (Array.isArray(array)) {\r\n        array = {\r\n            data: array,\r\n        };\r\n    }\r\n    if (!array.numComponents) {\r\n        array.numComponents = guessNumComponentsFromName(name, array.length);\r\n    }\r\n    var type = array.type;\r\n    if (!type) {\r\n        if (name === \"indices\") {\r\n            type = Uint16Array;\r\n        }\r\n    }\r\n    var typedArray = createAugmentedTypedArray(array.numComponents, array.data.length / array.numComponents | 0, type);\r\n    typedArray.push(array.data);\r\n    return typedArray;\r\n}\r\n/**\r\n * Creates a set of attribute data and WebGLBuffers from set of arrays\r\n *\r\n * Given\r\n *\r\n *      var arrays = {\r\n *        position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\r\n *        texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\r\n *        normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\r\n *        color:    { numComponents: 4, data: [255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255], type: Uint8Array, },\r\n *        indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\r\n *      };\r\n *\r\n * returns something like\r\n *\r\n *      var attribs = {\r\n *        a_position: { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\r\n *        a_texcoord: { numComponents: 2, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\r\n *        a_normal:   { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\r\n *        a_color:    { numComponents: 4, type: gl.UNSIGNED_BYTE, normalize: true,  buffer: WebGLBuffer, },\r\n *      };\r\n *\r\n * @param {WebGLRenderingContext} gl The webgl rendering context.\r\n * @param {Object.<string, array|typedarray>} arrays The arrays\r\n * @param {Object.<string, string>} [opt_mapping] mapping from attribute name to array name.\r\n *     if not specified defaults to \"a_name\" -> \"name\".\r\n * @return {Object.<string, module:webgl-utils.AttribInfo>} the attribs\r\n * @memberOf module:webgl-utils\r\n */\r\nfunction createAttribsFromArrays(gl, arrays, opt_mapping) {\r\n    var mapping = opt_mapping || createMapping(arrays);\r\n    var attribs = {};\r\n    Object.keys(mapping).forEach(function (attribName) {\r\n        var bufferName = mapping[attribName];\r\n        var origArray = arrays[bufferName];\r\n        var array = makeTypedArray(origArray, bufferName);\r\n        attribs[attribName] = {\r\n            buffer: createBufferFromTypedArray(gl, array),\r\n            numComponents: origArray.numComponents || array.numComponents || guessNumComponentsFromName(bufferName),\r\n            type: getGLTypeForTypedArray(gl, array),\r\n            normalize: getNormalizationForTypedArray(array),\r\n        };\r\n    });\r\n    return attribs;\r\n}\r\n/**\r\n * Creates a BufferInfo from an object of arrays.\r\n *\r\n * This can be passed to {@link module:webgl-utils.setBuffersAndAttributes} and to\r\n * {@link module:webgl-utils:drawBufferInfo}.\r\n *\r\n * Given an object like\r\n *\r\n *     var arrays = {\r\n *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\r\n *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\r\n *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\r\n *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\r\n *     };\r\n *\r\n *  Creates an BufferInfo like this\r\n *\r\n *     bufferInfo = {\r\n *       numElements: 4,        // or whatever the number of elements is\r\n *       indices: WebGLBuffer,  // this property will not exist if there are no indices\r\n *       attribs: {\r\n *         a_position: { buffer: WebGLBuffer, numComponents: 3, },\r\n *         a_normal:   { buffer: WebGLBuffer, numComponents: 3, },\r\n *         a_texcoord: { buffer: WebGLBuffer, numComponents: 2, },\r\n *       },\r\n *     };\r\n *\r\n *  The properties of arrays can be JavaScript arrays in which case the number of components\r\n *  will be guessed.\r\n *\r\n *     var arrays = {\r\n *        position: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0],\r\n *        texcoord: [0, 0, 0, 1, 1, 0, 1, 1],\r\n *        normal:   [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],\r\n *        indices:  [0, 1, 2, 1, 2, 3],\r\n *     };\r\n *\r\n *  They can also by TypedArrays\r\n *\r\n *     var arrays = {\r\n *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),\r\n *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),\r\n *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),\r\n *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),\r\n *     };\r\n *\r\n *  Or augmentedTypedArrays\r\n *\r\n *     var positions = createAugmentedTypedArray(3, 4);\r\n *     var texcoords = createAugmentedTypedArray(2, 4);\r\n *     var normals   = createAugmentedTypedArray(3, 4);\r\n *     var indices   = createAugmentedTypedArray(3, 2, Uint16Array);\r\n *\r\n *     positions.push([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]);\r\n *     texcoords.push([0, 0, 0, 1, 1, 0, 1, 1]);\r\n *     normals.push([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);\r\n *     indices.push([0, 1, 2, 1, 2, 3]);\r\n *\r\n *     var arrays = {\r\n *        position: positions,\r\n *        texcoord: texcoords,\r\n *        normal:   normals,\r\n *        indices:  indices,\r\n *     };\r\n *\r\n * For the last example it is equivalent to\r\n *\r\n *     var bufferInfo = {\r\n *       attribs: {\r\n *         a_position: { numComponents: 3, buffer: gl.createBuffer(), },\r\n *         a_texcoods: { numComponents: 2, buffer: gl.createBuffer(), },\r\n *         a_normals: { numComponents: 3, buffer: gl.createBuffer(), },\r\n *       },\r\n *       indices: gl.createBuffer(),\r\n *       numElements: 6,\r\n *     };\r\n *\r\n *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_position.buffer);\r\n *     gl.bufferData(gl.ARRAY_BUFFER, arrays.position, gl.STATIC_DRAW);\r\n *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_texcoord.buffer);\r\n *     gl.bufferData(gl.ARRAY_BUFFER, arrays.texcoord, gl.STATIC_DRAW);\r\n *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_normal.buffer);\r\n *     gl.bufferData(gl.ARRAY_BUFFER, arrays.normal, gl.STATIC_DRAW);\r\n *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferInfo.indices);\r\n *     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrays.indices, gl.STATIC_DRAW);\r\n *\r\n * @param {WebGLRenderingContext} gl A WebGLRenderingContext\r\n * @param {Object.<string, array|object|typedarray>} arrays Your data\r\n * @param {Object.<string, string>} [opt_mapping] an optional mapping of attribute to array name.\r\n *    If not passed in it's assumed the array names will be mapped to an attribute\r\n *    of the same name with \"a_\" prefixed to it. An other words.\r\n *\r\n *        var arrays = {\r\n *           position: ...,\r\n *           texcoord: ...,\r\n *           normal:   ...,\r\n *           indices:  ...,\r\n *        };\r\n *\r\n *        bufferInfo = createBufferInfoFromArrays(gl, arrays);\r\n *\r\n *    Is the same as\r\n *\r\n *        var arrays = {\r\n *           position: ...,\r\n *           texcoord: ...,\r\n *           normal:   ...,\r\n *           indices:  ...,\r\n *        };\r\n *\r\n *        var mapping = {\r\n *          a_position: \"position\",\r\n *          a_texcoord: \"texcoord\",\r\n *          a_normal:   \"normal\",\r\n *        };\r\n *\r\n *        bufferInfo = createBufferInfoFromArrays(gl, arrays, mapping);\r\n *\r\n * @return {module:webgl-utils.BufferInfo} A BufferInfo\r\n * @memberOf module:webgl-utils\r\n */\r\nfunction createBufferInfoFromArrays(gl, arrays, opt_mapping) {\r\n    var bufferInfo = {\r\n        attribs: createAttribsFromArrays(gl, arrays, opt_mapping),\r\n    };\r\n    var indices = arrays.indices;\r\n    if (indices) {\r\n        indices = makeTypedArray(indices, \"indices\");\r\n        bufferInfo.indices = createBufferFromTypedArray(gl, indices, gl.ELEMENT_ARRAY_BUFFER);\r\n        bufferInfo.numElements = indices.length;\r\n    }\r\n    else {\r\n        bufferInfo.numElements = getNumElementsFromNonIndexedArrays(arrays);\r\n    }\r\n    return bufferInfo;\r\n}\r\n/**\r\n * Calls `gl.drawElements` or `gl.drawArrays`, whichever is appropriate\r\n *\r\n * normally you'd call `gl.drawElements` or `gl.drawArrays` yourself\r\n * but calling this means if you switch from indexed data to non-indexed\r\n * data you don't have to remember to update your draw call.\r\n *\r\n * @param {WebGLRenderingContext} gl A WebGLRenderingContext\r\n * @param {module:webgl-utils.BufferInfo} bufferInfo as returned from createBufferInfoFromArrays\r\n * @param {enum} [primitiveType] eg (gl.TRIANGLES, gl.LINES, gl.POINTS, gl.TRIANGLE_STRIP, ...)\r\n * @param {number} [count] An optional count. Defaults to bufferInfo.numElements\r\n * @param {number} [offset] An optional offset. Defaults to 0.\r\n * @memberOf module:webgl-utils\r\n */\r\nfunction drawBufferInfo(gl, bufferInfo, primitiveType, count, offset) {\r\n    var indices = bufferInfo.indices;\r\n    primitiveType = primitiveType === undefined ? gl.TRIANGLES : primitiveType;\r\n    var numElements = count === undefined ? bufferInfo.numElements : count;\r\n    offset = offset === undefined ? offset : 0;\r\n    if (indices) {\r\n        gl.drawElements(primitiveType, numElements, gl.UNSIGNED_SHORT, offset);\r\n    }\r\n    else {\r\n        gl.drawArrays(primitiveType, offset, numElements);\r\n    }\r\n}\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\r\n    resizeCanvasToDisplaySize,\r\n    createProgram,\r\n    createProgramFromStrings,\r\n    createProgramInfo,\r\n    createAttributeSetters,\r\n    createBufferInfoFromArrays,\r\n    createAugmentedTypedArray,\r\n    drawBufferInfo,\r\n    setBuffersAndAttributes,\r\n    setUniforms,\r\n});\r\n\n\n//# sourceURL=webpack://MyLibrary/./src/resources/webgl-utils.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	MyLibrary = __webpack_exports__;
/******/ 	
/******/ })()
;